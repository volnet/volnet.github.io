MongoDB应用设计模式
==================

前言
------------------

本书可提供用户需要的MongoDB特性和姐姐商业应用上的问题。本书重点关注MongoDB具体实现中遇到的实践性问题，特别适合那些希望利用MongoDB来应对特定扩展性问题的开发者阅读。

尽管本书对大部分MongoDB特性有一个基本描述，但本书并不是一本关于MongoDB的入门书籍。

第一部分 设计模式
------------------

第1章 嵌入还是引用
------------------

关系型数据库中，为了满足第一范式，可能带来冗余，为了消除冗余，可能要增加表。它给插入和更新记录都带来了一定的复杂性。

更大的问题在于，从多张表中查询数据，需要进行join操作，而该操作会导致磁盘的随机寻道。如果只查询一行记录，寻址时间占到了整个数据读取时间的99%以上。

即便现代的数据库都采用了一些内存对象来缓存优化，但是join操作还是非常昂贵的。

为了减少join带来的性能影响，一些系统又被设计成满足第一范式的，从而带来了大量的冗余。

MongoDB有一个概念就是数据不必总是列成表格，基本上否决了传统数据库从第一范式开始进行标准化的操作。

MongoDB即允许采用嵌入的方式存储文档，也可以按照标准化的方式（引用）存储文档：

嵌入的方式：

```
{
    "_id":3,
    "name":"Jenny",
    "zip_code":"01209",
    "numbers":["555-333-3456", "555-334-3411"]
}
```
标准化的方式（引用）：
```
// 联系人文档：
{
    "_id":3,
    "name":"Jenny",
    "zip_code":"01209"
}
// 电话号码文档：
{"contact_id":3, "number":"555-333-3456"}
{"contact_id":3, "number":"555-334-3411"}
```

嵌入模式：

- 可以支持一对多关系
- 希望保持数据的原子性和独立性
- 提供最好的性能和数据完整性保证

引用模式：

- 将用户数据模型标准化到多个容器，将会提升执行查询的灵活性，从而获得更好的性能。
- 有十分高或者无法预测的引数的一对多关系时。举例来说，一个拥有大量读者参与度的流行博客中，某个博客文章可能有成百上千的评论。如果采用嵌入方式就会带来明显的损失：
    - 文档越大，使用的内存就越大
    - 增长的文档最终必须拷贝到更大的空间中。
    - MongoDB文档最大不能超过16MB。

如何选择：

- 如果应用程序的查询模式是常见的，并且倾向于采用一种方式访问数据，那么嵌入式的途径就可以很好的工作。如果应用程序可能采用多种方式查询数据，或者您无法预计数据查询的模式，那么采用更“标准化”（引用）的方式可能更好。

多对多关系：

- 采用引用的方式，会导致查询过程较复杂
- 采用嵌入的方式，会导致更新的时候会导致需要更新所有潜入了该对象的文档的信息。
- 建议：采用折中的方式，嵌入_id的列表，而不是嵌入完整的文档。

总的来说，使用哪种方式取决于应用程序的访问方式，在MongoDB中很少有类似关系型数据库中所必须遵循的规则。灵活地使用MongoDB所提供的模式设计将有助于更好地使用这个强大的非关系型数据库。

第2章 多态模式
------------------

当集合中所有文档的结构都是类似的，但不是完全相同的时候，我们称为多态模式。

### 多态模式支持面向对象编程

如果要在关系型数据库中使用关系表来存储内容，可能遇到下面的问题：

- 单一表模型：单独的表包含所有的内容，但是不是所有的行都包含所有的列，存在空间浪费。
- 具体表模型：如果为不同的对象创建不同的表，那么查询的时候就要查询所有这些对象，变得复杂。
- 多态模型：采用引用的方式，可以减少浪费，但是需要联合查询。

如果使用MongoDB，可以将稍有差异的对象存储在一起，形成一个集合，不会产生存储空间浪费，而且查询语句和单一表模型一样简单，并具有具体表模型一样的效率。

### 多态模式使得模式进化成为可能

如果修改关系型数据库表，需要用到`ALTER TABLE`，但是效率很低。用MongoDB，效率一样很低。

但是可以通过在前台代码中使用设置默认值的代码（`node.setdefault('short_description', '')`），然后在后台，一部分一部分地修改数据，而不是对整个数据集修改数据结构的方式来缓解这个问题。

#### BSON的存储效率

MongoDB有一个主要的缺点时缺乏强制模式，这就是存储效率。主要表现在每一个文档都要存储字段的名字和类型。

为了减轻存储的压力，应该采用较短的字段名取代较长的字段名。但是这样做使得在shell中直接查看数据库变得困难。

一种改进存储效率的方法是使用MongoDB的对象-文档映射（object-document mapper，ODM），如Python中的MongoEngine、MongoKit和Ming。

### 多态模式支持半结构域数据

除了使用面向对象的多态模式来支持不同记录（行）之间存在差异字段（列）的模式之外，还可以使用一个通用的属性数组来表示一些不确定的项，并可以通过建立索引来加速查询。

第3章 模仿事务行为
------------------

### 一致性的有关方法

如果是针对单行数据的操作，本身就是原子级的，但并非所有的操作都是单行数据操作，比如：

- 情况1：一对多数据的删除，不仅要删除“一”还要删除“多”。
- 情况2：类似一种数据冗余，删除一行数据的时候，可能要修改另一个统计值（比如统计值是由删除的一行数据的一些字段组成的）。
- 情况3：进出互补的操作，如银行转账操作，出账和入账必须保持事务性。

一般的关系型数据库采用两段式的多状态事务进行提交，不适应分布式的场景。

### 混合文档

针对情况1：

当存在一对多的数据的时候，如果使用关系型数据库的设计方法，通常是设计成两张表，在发生删除操作的时候，包在一个事务中。如果支持级联约束，可以仅删除“一”，可同时删除“多”，但实际上在数据库内部仍然用到了事务。

如果在MongoDB中，如果采用类似关系型数据库的方法进行设计，则同样面临事务的问题，在遭遇意外的时候，将会出现部分数据未删除的情况。

要想保持原子性，可以将“一对多”关系存在单行数据中。

### 使用复杂更新

针对情况2：

可以使用MongoDB的原子更新操作，同时检查返回值来检查更新操作是否真正成功。

如果某个对象在进行原子更新操作的时候，执行失败了，说明其他人已经删除了该条目，则此时就不进行更新操作了，而是将它放进数组中。

### 使用补偿来优化更新

针对情况3：

创建一个“事务”集合来包含所有未完成的转账状态：

- 如果超时，任何位于“new”状态的事务将回滚。
- 任何位于“committed”状态的事务最终将被撤销。
- 任何位于“rollback”状态的事务最终将回滚。

这个模型包含一组方法：

- prepare_transfer：将事务对象放进事务列表中，然后完成实际的数据修改，并将事务ID也放进具体的数据中。
    - 源账户和目标账户存储了一个挂起的事务列表。以便可以在账户文档中追踪查看特定的事务ID是否处于挂起状态。
    - 事务本身必须在特定时间窗口中完成。如果没有完成，定期进程将回滚未完成的事务，或者根据该事务的最终状态来提交。这将处理应用程序或数据库在事务执行过程中崩溃的情形。
- commit_transfer：将事务的状态从new原子更新为commit。如果更新成功，该事务将退役，甚至在更新后立即发生崩溃。
- retire_transcation：退役一个事务的方法。从具体的数据中将事务ID移除，从事务列表中移除事务对象。同时这个方法是幂等的，可以多次重复操作。
- cleanup_transcation：对于状态为commit的事务对象，执行`retire_transcation`，对超时完成的事务对象，标记状态为rollback，对于标记为状态为rollback的对象，执行`rollback_transfer`方法。
- rollback_transfer：执行回滚操作。从具体的数据中，执行数据修改，调整为修改前的数值，将事务ID从具体的数据中移除，将事务对象从事务列表中移除。

第二部分 应用实例
------------------

第4章 运营智能
------------------

### 存储日志数据

#### 模式设计

- 仅将必要的内容存储进日志。
- 注意日志内容的格式，比如充分利用BSON格式的内置类型。

#### 操作

##### 插入日志记录

事件日志系统需要主要考虑如下性能指标：

- 可以支持每秒多少次插入操作，这将限制事件的吞吐量。
- 该系统如何管理事件数据的增长，特别在插入活动时的增长。

通过调整MongoDB的Write Concern，可以在存入数据库的重要性和插入速度之间及进行平衡。通过`db.events.insert(event, w=1)`、`db.events.insert(event, w=2)`、`db.events.insert(event, j=True)`、`db.events.insert(event, j=True, w=2)`等选项来控制这个平衡。

##### 批量插入

可以使用`insert()`函数一次传递多个事件。如果正在进行一个批量插入并遇到错误（或者是网络中断，或者是唯一性冲突），应用程序需要处理这种部分批量插入的可能性。如果在某些特殊情形下不在意丢失一些插入数据，可以为插入增加一个`continue_on_error=True`的参数，在该情形下插入操作将插入尽可能多的数据，并在最后一次插入失败后给出错误报告。

##### 查找特定页面的所有事件

可以为待查询的字段增加索引。

##### 旁白：管理索引大小

创建索引的大小会占用RAM。当随机访问一个索引时，在现在这个情形下是访问path索引，需要将所有的索引都驻留内存。

可以使用collstats数据库命令来查看索引的大小：

```
db.command('collstats', 'events')['indexSizes']
```

##### 查找特定事件的所有事件

查找某个特定时间段的事件的时候，索引将会优化性能，同时这种索引是一个右对齐索引，不会全部载入内存。

##### 查找特定主机/日期的所有事件

在同时查询两个条件（例子中是主机+时间范围）的时候，可以使用组合索引来优化性能，值得注意的是组合索引是有顺序的。

```
db.events.ensure_index([('time':1),('host':1)])
```
或
```
db.events.ensure_index([('host':1),('time':1)])
```

##### 索引设计规则

因为索引是使用B树存储的，那么下面的这些规则将有利于提高使用效率：

- 任何需要平等查询的字段都应该在索引定义的前面出现。
- 用于排序的字段应该在出现索引定义后。如果采用多个字段排序（例如last_name，first_name），那么应该和索引定义中出现的顺序相同。
- 采用区间查询的字段应该在索引定义的最后出现。

这会导致出现一些不幸的场景，在这些场景下索引无法最优化使用：

- 无论何时使用两个或者更多属性的范围查询，那么在索引中这多个属性就无法同时有效；
- 无论何时在使用区间查询时，如果合并使用了一个不同属性的排序，那么索引的效率会比相同属性集排序的方式效率低一些。

在上述情形下，最佳的方法是使用代表性的数据来测试，并多使用explain()方法。如果发现MongoDB查询优化器正在选择一种不好的索引方式（比如在进行巨大的内存里排序时，选择降低条目扫描的数量），也可以使用hint()方法高速如何选择索引。

##### 根据日期和页面来计算请求

处理一些聚合操作，比如`$sum`等操作，可以使用MongoDB2.1版本的聚合框架来选择、处理和聚合来自海量文档的结果，进而实现更强大的特定查询。（建议阅读原作参看示例代码P47）

等价的SQL类似于：含有where和group by的语句。

注意必须确保初始的$match查询有一个索引。

#### 分片需要考虑事项

##### 限制

在分片环境中，最大插入速率的限制是：

- 集群的分片数目。
- 选择的片键。

因为MongoDB使用基于片键范围的分块来分布数据，片键的选择可以控制MongoDB的数据分布，并影响系统写入和查询的性能。

理想情况下，片键应具备两个特性：

- 在各个分片之间平衡数据插入。
- 大多数查询可以路由到满足需要的分片的子集。

##### 选择1：根据时间分片

尽管使用时间戳，或者是使用_id字段的ObjectId，会将数据平均分布在各个分片上，这些片键会导致两个问题：

- 所有插入操作总是流向相同的分片，这就意味着分片集群拥有和单个实例相同的吞吐量。
- 假定频繁访问近期数据，那么大多数读操作倾向于读取集群中相同的分片。

##### 选择2：根据半随机键来分片

比如使用基于_id的hash值作为片键，可以分散写压力，但是存在如下缺点：

- 片键和片键的索引将消耗数据库的额外的存储空间。
- 查询，除非它们包含了片键本身，必须在所有分片上并行执行，这将导致性能的下降。

##### 选择3：根据数据集中平均分布的键来进行分片

如果文档中某个字段的值是在文档中平均分布的，那么强烈建议考虑使用该键来作为片键。这样做有很多的好处：

- 可以平均分布各个分片的写操作。
- 读操作可以是有选择的，如果查询选择指定path字段，那么可以定位到单个分片上。

潜在的缺陷是：所有命中一个特定的查询条件都必须指向同一个文件块，该块不能被MongoDB切分，因为在该块中的所有文档都有相同的片键。如果负载比较平均，则可能不是问题。但是如果负载不均匀，最终就会导致生成一个很大的文件块，该文件块不能被切分，并导致分片上的负载无法平衡。

##### 选择4：根据综合使用固有的和合成的键来进行分片

MongoDB支持采用组合片键，该组合键可以综合选择2和选择3的的最佳方面。

##### 测试自己的数据

选择片键十分困难的，因为没有决定性的“最佳实践”，分片的选择在很大程度上影响了性能，并且在选定片键后很难，或者几乎是不可能重新选择片键。

选择片键的最好的方法还是分析应用程序中真实的插入操作和查询操作。

#### 管理事件数据增长

MongoDB中的即使是数据已经从数据库中移除后，数据库文件在磁盘中的大小将永远不会缩小。

##### 有上限的集合

有上限的集合（capped collection）拥有一个固定的大小，在插入新数据达到上限时，会自动丢弃旧的数据。且当前版本中还不支持对有上限的集合进行分片。

##### TTL集合

如果希望既具备类似有上限的集合的功能，同时又可以分片，那么可以考虑使用在集合上使用“生存时间”（TTL）索引。如果在集合上定义了TTL索引，那么MongoDB使用remove()操作定期从集合中移除旧的文档。

相比有上限的集合，TTL索引不具备性能优势，它只是使用了remove方法，会导致数据碎片，并且在移除旧文档时仍然会触发索引查询。

##### 多集合，单数据库

定期重命名事件集合，以便数据集合可以像日志文件一样进行轮换。

##### 多数据库

循环使用数据库，而不是如之前的“多集合，单数据库”那样循环使用集合。

### 预聚合报告

#### 解决方案概述

支持分钟级、秒级的实时数据。

它实际上就是提前设计一个目标统计的模型，然后在记录日志的同时，更新该统计模型的值，以便在需要查询的时候，直接读取这个统计模型，而不是从原始数据中进行计算。

#### 模式设计

##### 每天每个页面单个文档，文本文档格式

优势：

- 对于网站上每个请求，只需要更新一个文档。
- 关于一天内针对单个网页的报告只需要访问单个文档。

同时，如果一些值是在填入数据的时候才赋值，那么在数据添加到该字段的时候，文档会变大，这可能导致MongoDB要重新分配这些文档，从而导致性能下降（大意是：动态分配空间）。可以使用提前分配的方式，先给预留数据，比如默认0，后续只需要update这个字段即可。

##### 每天每个页面一个文档，分层文档格式

一个较大的文档对象，如：

```
minutes:{
    "0": 3612,
    "1": 3241,
    ...
    "1439": 2819
}
```

访问0和访问1439的性能是不同的，因为在MongoDB的内部，它的表现实际上是一个键值对的数组，需要按序扫描来查找实际所需要更新的值的具体位置。

为了解决较大文档对象的问题，可以将这些值进行细分，比如该例子中，表示的是一天的分钟数，那么可以先拆解为24个小时，再将不同的分钟数放置到下面，从而提高性能：

```
minutes:{
    "0":{   "0": 3612,
            "1": 3241,
            ...
            "59": 2833
        }
    "1":{   "60": 3233,
            "61": 313,
            ...
            "119": 839
        }
    ...
    "23":{  
            ...
            "1439": 2819
        }
}
```

##### 根据粒度级别划分文档

以上的示例是针对网页的日统计，如果要增加月统计，可以依葫芦画瓢再加一个类似的，只不过这次是针对月级别的。

#### 操作

可以使用upsert=True来实现原地更新。

同时可以直接读取统计结果，用来展示。

#### 获取创建历史图表的数据

通过设定条件，并匹配索引，可以高效查询单个网页过去几个月内的查询。

#### 分片需要考虑事项

在这个示例中，可以按照site-page-date进行分片，以获得较好的扩展性。

### 分层聚合

使用MapReduce的方法从原始数据中分层计算数据结果集。以本章例子来看：

事件日志->小时级统计->天级统计->周级统计->月级统计->年级统计。

高级的输入可以由低级的输入来组成。

（因示例复杂，建议阅读原文）

第5章 电子商务
------------------

### 产品目录

本节内容围绕如何构建一个产品目录展开。

#### 解决方案概述

##### 具体表继承

关系型模型中一种方法是为每个产品类别创建一个表。

##### 单表继承

关系型模型中，为所有产品使用单个表，然后在不同类目差异的时候，增加新的字段。

##### 多表继承

关系型模型中，把通用属性放在主表中，然后为不同的类目的差异化字段建立单独的子表。

##### 实例属性值（entity-attribute-value，EAV）模式

增加一个Attribute字段用来描述字段的名称，每个字段一行。这种模式导致查询起来比较困难。

##### 避免对所有产品数据建模

有些解决方案忽略关系型建模，将所有产品数据序列化存入一个BLOB列。但该方法无法对数据排序和过滤。

##### MongoDB的解决方案

类似于单表继承，但是针对不同的类型不必维护相同的模式。

#### 操作

作者举例个各种查询的例子，同时也提到了全文检索，为了确保效率，对这种更新频率不高的类型，建议对所有事物进行索引，因为我们无法预测用户会搜索哪个字段。

#### 分片需要考虑事项

合理的分片有助于改善性能。

对于那些难以切分的数据，可以考虑在查询的时候制定特定的副本集，从而获得额外的读性能。

### 分类层级

#### 解决方案简介

目标是设计一个类似音乐分类层级的结构

##### 模式设计

- 在每个文档中都存储parent_id值，该值是个名称
- 在每个文档的parent中，存放名称路径
- 在每个文档的parent中，存放一个ObjectId，并将名称值移动到单独的字段中。为了解决查询的问题，引入一个“祖先文档”的概念，在每个文档中存放一个数组，表示其祖先文档。

##### 操作

针对祖先文档模式，示范了以下几种场景：

- 读取和显示分类
- 为层次结构增加分类：构建祖先分类的方法
- 更改分类的祖先：构建子图的方法、更新节点和后代的方法
- 更改分类的名称

##### 分片需要考虑事项

如果确定需要进行分片，因为所有的查询都是用`_id`，所以可以对`_id`进行分片。

### 存货管理

#### 解决方案概述

通过对购物车和库存的状态维护，来保持正确性。

#### 模式

在库存列表中，包含carted数组，表示已经放入购物车的数量。

在购物车列表中，包含items数组，表示放入了哪些商品，并将商品的具体信息复制过来，避免每次都关联查询，同时也导致了商品显示价格始终是加入购物车时的价格。

#### 操作

##### 为购物车增加条目

- 更新购物车，确保该购物车仍然活动，并将商品加入购物车。
- 更新存货，在有充足库存的前提下减少有效库存。
- 如果存货更新失败，由于缺少存货，那么回退该购物车更新操作，并给用户发送一个异常。

> 疑问：作者为啥不先更新存货，等价于锁定商品后，直接更新购物车呢，毕竟购物车属于非争用资源，而库存属于争用资源。

##### 修改购物车中的数量

- 更新购物车（乐观地假设有足够的库存）
- 如果有足够的库存，更新product集合
- 如果没有足够的库存，就回滚购物车，并抛出异常。

##### 结账

- 收集付款详情。
- 一旦付款完成，更新carted项目。

基本算法如下：

- 通过将购物车设置为pending状态来锁定购物车。
- 收集购物的付款情况。如果付款失败，通过将购物车设置为active状态来解锁购物车。
- 将购物车状态设置为complete
- 移除product集合中来自任何carted属性对该购物车的所有饮用。

##### 返回来自超时购物车的库存

- 找到所有超过设定阈值的过期的购物车。将其锁定，并将状态设置为expiring。
- 对于每个状态为expiring的购物车，将购物车中所有商品返回给可用库存。
- 一旦product集合更新完毕，将购物车状态设置为expired。

##### 错误处理

- 载入可能过期的购物车。如果该购物车仍然是活动的，在product中刷新carted条目。
- 如果一个活动的购物车没有找到匹配的carted条目，那么这个carted条目将移除，并更新可用库存。

#### 分片需要考虑事项

如果需要为该系统实现分片，那么`_id`字段将是一个很好的片键选择，这是因为大多数更新在具体实现上都会使用`_id`字段，使得mongos可以将每个更新引导到mongod进程。然而也有一些使用`_id`字段的缺陷，例如：

- 如果购物车集合的`_id`是一个增长的值，例如ObjectId()，所有新的购物车最终都会落在单个分片上。
- 当使用`_id`作为片键时，购物车过期和库存调整需要将更新操作和查询操作广播到所有分片上。

可以通过在创建购物车时，使用一个伪随机的`_id`值来减轻第一个问题带来的影响。比如使用hash值。

第6章 内容管理系统
------------------

### 元数据和资源管理

#### 解决方案概述

将一个CMS分为基本页面、博客帖子、图片三种大类。

#### 模式设计

针对每一种大类，定制不同的metadata，并将detail设置为具体的内容。

采用GridFS（存储大块二进制数据的一种常见的客户端实现）存储图片。

#### 操作

##### 创建和编辑文档节点

通过使用nonce字段，每次新生成一个ObjectId，保证不会发生编辑冲突。冲突的场景大概是：

- Alice保存更改。刷新页面看到她的新版本页面。
- 然后Bob保存他的更改。刷新页面看到他的新版本。
- Alice和Bob同时刷新页面，他们都看到Bob的版本，Alice的版本丢失了，并且Bob并不知道他覆盖了Alice的版本。

##### 上传图片

作者展示了如何使用GridFS上传新文件，并展示了如何更新文件的逻辑。

##### 定位和获取一个节点

可以使用GridFS的get_version方法来获取图片。

##### 根据标签搜索节点

通过`nodes = db.nodes.find({'metadata.tags' : tag })`来搜索标签。

##### 生成最近发布博客文章的feed

按照时间逆序排列的方式，用于网站索引页，或者用于RSS或ATOM的feed。

#### 分片需要考虑事项

在一个CMS中，读性能远比写性能重要。为了在分片的集群中获得最佳的读性能，需要确保mongos可以将查询路由到特定的分片上。

### 存储评论信息

#### 解决方案概述

有多种方法来存储评论，且没有哪种是绝对正确的：

- 在文档本身存储评论
- 将所有评论嵌入到父文档中
- 单独存储评论，但是将评论聚集在一起

#### 方式一：每个评论一个文档

##### 操作：发布新评论

使用insert操作来完成，大部分的逻辑在讲述如何生成full_slug

##### 操作：查看分页的评论

使用sort、skip、limit来实现分页的操作。

##### 操作：通过直接链接获取评论

使用full_slug字段，可以实现递归子查询。

#### 方法二：嵌入所有评论

##### 操作：发布一个新评论

使用update操作，将评论$push到comments中去。对于嵌套的评论，则需要在较深的层次进行更新。

##### 操作：查看分页评论

对于未嵌套的设计中查看评论，需要使用$slice操作。

对于嵌套设计，为了返回分页的评论，需要获取整个文档，并在应用程序中分页评论。

##### 操作：通过直接链接检索评论

同样需要针对未嵌套的设计使用$slice，为嵌套的评论，应用程序中处理。

#### 方法三：复合模式设计

在“复合方法”中，将会把评论存储到一个包含大约100条评论的“桶”中。每个文档维护page和count数据，除了包含评论本身的comments数组之外，还包含关于页面数量和页面中评论数的元数据。

##### 操作：发布一条新评论

不仅要update评论本身，还要$inc评论数。还要考虑当page中的值超过单页评论数的时候，需要增加page值，再更新数据。

##### 操作：查看分页评论

通过对这种文档执行skip和limit的计算来进行分页。

##### 操作：通过直接链接检索评论

为了直接检索评论，而不需要对所有之前的评论页面进行分页，使用slug来查找正确的页面，然后使用应用程序逻辑来查找正确的评论。

#### 分片需要考虑事项

将node_id作为片键。对于“每个评论一个文档”可以再增加slug作为片键。对于“复合文档”可以增加page字段作为片键。

第7章 在线广告网络
------------------

### 解决方案概述

按照一个逐步求精的广告网络来构建的系统。

### 设计一：基本广告服务

一个基本的广告服务算法由下面的步骤组成：

- 网络收到一个广告请求：指定了最小限度的需要服务的`site_id`和`zone_id`。
- 网络查询可用显示广告的清单，并根据多种商业规则选择一个广告。
- 网络返回用于显示的广告，同时记录该广告的浏览次数。

#### 模式设计

通过为每个站点和区域配置一组ads，通过eCPM值（千人印象成本）排序来挑选最合适的广告。

#### 操作：选择提供的广告

用groupby倒序排列，选出第一条广告。

#### 操作：停止广告活动

通过$pull操作移除停止的活动（可能因为费用耗尽，可能因为活动到期等原因）。

#### 分片需要考虑事项

根据`zone_id`进行分片。也可以针对`site_id`和`zone_id`来分片。

### 设计二：增加广告频次控制

为了避免反复显示相同的广告，需要限制用户查看同一个广告的频率。

#### 模式设计

为每个用户（通过cookie传递user_id值）记录profile文件，记录用户印象、点击、习惯等。

#### 操作：选择提供的广告

- 查找所有指向特定网站和区域的广告。
- 产生一个Python生成器，可以按照利润率顺序循环访问所有的广告。
- 现在为给定用户载入用户配置文件。如果没有配置文件，那么返回迭代器中的第一个广告。
- 循环访问每个广告，使用`ad_is_acceptable`函数进行检查。

#### 分片

使用_id字段分片即可。

### 设计三：关键字目标选择

通过用户搜索关键词，展示相关的广告，需要将关键词信息也发送给广告系统。

#### 模式设计

增加关键词列表到每个广告中。

#### 操作：选择一组提供的广告

通过`ad_iterator`中基于keywords进行筛选，然后再进行展示，因此能够筛选出符合搜索关键词的广告。

第8章 社交网络
------------------

第9章 在线游戏
------------------

后记
------------------