MongoDB应用设计模式
==================

前言
------------------

本书可提供用户需要的MongoDB特性和姐姐商业应用上的问题。本书重点关注MongoDB具体实现中遇到的实践性问题，特别适合那些希望利用MongoDB来应对特定扩展性问题的开发者阅读。

尽管本书对大部分MongoDB特性有一个基本描述，但本书并不是一本关于MongoDB的入门书籍。

第一部分 设计模式
------------------

第1章 嵌入还是引用
------------------

关系型数据库中，为了满足第一范式，可能带来冗余，为了消除冗余，可能要增加表。它给插入和更新记录都带来了一定的复杂性。

更大的问题在于，从多张表中查询数据，需要进行join操作，而该操作会导致磁盘的随机寻道。如果只查询一行记录，寻址时间占到了整个数据读取时间的99%以上。

即便现代的数据库都采用了一些内存对象来缓存优化，但是join操作还是非常昂贵的。

为了减少join带来的性能影响，一些系统又被设计成满足第一范式的，从而带来了大量的冗余。

MongoDB有一个概念就是数据不必总是列成表格，基本上否决了传统数据库从第一范式开始进行标准化的操作。

MongoDB即允许采用嵌入的方式存储文档，也可以按照标准化的方式（引用）存储文档：

嵌入的方式：

```
{
    "_id":3,
    "name":"Jenny",
    "zip_code":"01209",
    "numbers":["555-333-3456", "555-334-3411"]
}
```
标准化的方式（引用）：
```
// 联系人文档：
{
    "_id":3,
    "name":"Jenny",
    "zip_code":"01209"
}
// 电话号码文档：
{"contact_id":3, "number":"555-333-3456"}
{"contact_id":3, "number":"555-334-3411"}
```

嵌入模式：

- 可以支持一对多关系
- 希望保持数据的原子性和独立性
- 提供最好的性能和数据完整性保证

引用模式：

- 将用户数据模型标准化到多个容器，将会提升执行查询的灵活性，从而获得更好的性能。
- 有十分高或者无法预测的引数的一对多关系时。举例来说，一个拥有大量读者参与度的流行博客中，某个博客文章可能有成百上千的评论。如果采用嵌入方式就会带来明显的损失：
    - 文档越大，使用的内存就越大
    - 增长的文档最终必须拷贝到更大的空间中。
    - MongoDB文档最大不能超过16MB。

如何选择：

- 如果应用程序的查询模式是常见的，并且倾向于采用一种方式访问数据，那么嵌入式的途径就可以很好的工作。如果应用程序可能采用多种方式查询数据，或者您无法预计数据查询的模式，那么采用更“标准化”（引用）的方式可能更好。

多对多关系：

- 采用引用的方式，会导致查询过程较复杂
- 采用嵌入的方式，会导致更新的时候会导致需要更新所有潜入了该对象的文档的信息。
- 建议：采用折中的方式，嵌入_id的列表，而不是嵌入完整的文档。

总的来说，使用哪种方式取决于应用程序的访问方式，在MongoDB中很少有类似关系型数据库中所必须遵循的规则。灵活地使用MongoDB所提供的模式设计将有助于更好地使用这个强大的非关系型数据库。

第2章 多态模式
------------------

当集合中所有文档的结构都是类似的，但不是完全相同的时候，我们称为多态模式。

### 多态模式支持面向对象编程

如果要在关系型数据库中使用关系表来存储内容，可能遇到下面的问题：

- 单一表模型：单独的表包含所有的内容，但是不是所有的行都包含所有的列，存在空间浪费。
- 具体表模型：如果为不同的对象创建不同的表，那么查询的时候就要查询所有这些对象，变得复杂。
- 多态模型：采用引用的方式，可以减少浪费，但是需要联合查询。

如果使用MongoDB，可以将稍有差异的对象存储在一起，形成一个集合，不会产生存储空间浪费，而且查询语句和单一表模型一样简单，并具有具体表模型一样的效率。

### 多态模式使得模式进化成为可能

如果修改关系型数据库表，需要用到`ALTER TABLE`，但是效率很低。用MongoDB，效率一样很低。

但是可以通过在前台代码中使用设置默认值的代码（`node.setdefault('short_description', '')`），然后在后台，一部分一部分地修改数据，而不是对整个数据集修改数据结构的方式来缓解这个问题。

#### BSON的存储效率

MongoDB有一个主要的缺点时缺乏强制模式，这就是存储效率。主要表现在每一个文档都要存储字段的名字和类型。

为了减轻存储的压力，应该采用较短的字段名取代较长的字段名。但是这样做使得在shell中直接查看数据库变得困难。

一种改进存储效率的方法是使用MongoDB的对象-文档映射（object-document mapper，ODM），如Python中的MongoEngine、MongoKit和Ming。

### 多态模式支持半结构域数据

除了使用面向对象的多态模式来支持不同记录（行）之间存在差异字段（列）的模式之外，还可以使用一个通用的属性数组来表示一些不确定的项，并可以通过建立索引来加速查询。

第3章 模仿事务行为
------------------

### 一致性的有关方法

如果是针对单行数据的操作，本身就是原子级的，但并非所有的操作都是单行数据操作，比如：

- 情况1：一对多数据的删除，不仅要删除“一”还要删除“多”。
- 情况2：类似一种数据冗余，删除一行数据的时候，可能要修改另一个统计值（比如统计值是由删除的一行数据的一些字段组成的）。
- 情况3：进出互补的操作，如银行转账操作，出账和入账必须保持事务性。

一般的关系型数据库采用两段式的多状态事务进行提交，不适应分布式的场景。

### 混合文档

针对情况1：

当存在一对多的数据的时候，如果使用关系型数据库的设计方法，通常是设计成两张表，在发生删除操作的时候，包在一个事务中。如果支持级联约束，可以仅删除“一”，可同时删除“多”，但实际上在数据库内部仍然用到了事务。

如果在MongoDB中，如果采用类似关系型数据库的方法进行设计，则同样面临事务的问题，在遭遇意外的时候，将会出现部分数据未删除的情况。

要想保持原子性，可以将“一对多”关系存在单行数据中。

### 使用复杂更新

针对情况2：

可以使用MongoDB的原子更新操作，同时检查返回值来检查更新操作是否真正成功。

如果某个对象在进行原子更新操作的时候，执行失败了，说明其他人已经删除了该条目，则此时就不进行更新操作了，而是将它放进数组中。

### 使用补偿来优化更新

针对情况3：

创建一个“事务”集合来包含所有未完成的转账状态：

- 如果超时，任何位于“new”状态的事务将回滚。
- 任何位于“committed”状态的事务最终将被撤销。
- 任何位于“rollback”状态的事务最终将回滚。

这个模型包含一组方法：

- prepare_transfer：将事务对象放进事务列表中，然后完成实际的数据修改，并将事务ID也放进具体的数据中。
    - 源账户和目标账户存储了一个挂起的事务列表。以便可以在账户文档中追踪查看特定的事务ID是否处于挂起状态。
    - 事务本身必须在特定时间窗口中完成。如果没有完成，定期进程将回滚未完成的事务，或者根据该事务的最终状态来提交。这将处理应用程序或数据库在事务执行过程中崩溃的情形。
- commit_transfer：将事务的状态从new原子更新为commit。如果更新成功，该事务将退役，甚至在更新后立即发生崩溃。
- retire_transcation：退役一个事务的方法。从具体的数据中将事务ID移除，从事务列表中移除事务对象。同时这个方法是幂等的，可以多次重复操作。
- cleanup_transcation：对于状态为commit的事务对象，执行`retire_transcation`，对超时完成的事务对象，标记状态为rollback，对于标记为状态为rollback的对象，执行`rollback_transfer`方法。
- rollback_transfer：执行回滚操作。从具体的数据中，执行数据修改，调整为修改前的数值，将事务ID从具体的数据中移除，将事务对象从事务列表中移除。

第二部分 应用实例
------------------

第4章 运营智能
------------------

第5章 电子商务
------------------

第6章 内容管理系统
------------------

第7章 在线广告网络
------------------

第8章 社交网络
------------------

第9章 在线游戏
------------------

后记
------------------