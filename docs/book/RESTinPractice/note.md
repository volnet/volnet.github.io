REST实战
==============

![](contents/cover.jpg)

作者：Jim Webber, Savas Parastatidis, Ian Robinson 著

李锟 余黎敏 马钧 译

第1章 将Web作为建造分布式系统的平台
------------------------------------------

### Web的架构

Web的架构中，URI和资源扮演了主要的角色，并得到Web缓存的支持以获得可伸缩性。

“404 Page Not Found”错误，这个适度的状态代码为分布式计算设置了一个新的、激进的方向：它明确地承认我们无法在所有的时间控制整个系统。

### 从资源的角度思考

从消费者的观点看，资源可以是消费者能够与之交互以达成某种目标的任何东西。

#### 资源与标识符

URI唯一标识了一个Web资源，同时使得资源在Web上是可寻址的，也能够使用一种类似HTTP的应用协议来操作。

> URL（过时的概念），是一个URI，用来表达关于与所标识的资源交互的方式的信息。比如HTTP方式通信，但并非所有的URI都需要表达特定交互协议的信息，比如URN，它有可能表达一本书的ISBN：urn:isbn:0131401602。

#### 资源表述

资源必须有至少一个标识符，以便于在Web上寻址，每个标识符与一个或多个表述相关联。一个表述，指的是某个资源在某特定时刻的状态的转化形式或视图。一个资源既可以用xml来表述也可以用纯文本来表述。

Web早期的成功依赖于类似浏览器这种代理能够正确将不同的表述以人能够识别的方式呈现给人，如浏览器可以正确显示网页、图片、音乐等信息。但这些资源表述的消费者，不仅是人，还可以是其他计算机。

#### 表述格式和URI

Rails框架的流行让类似`http://restbucks.com/order.xml`这样有明确表述要求的（`.xml`）的URI变得流行。

但更好的方式则是使用内容协商机制，通过HTTP的Accept请求头，与资源的提供者进行协商。URI对于消费者来说应该是不透明的。

#### 通信的艺术

HTTP使用动词（GET,POST,PUT……）来进行交互，同时也定义了一个响应代码的集合（例如：200 OK, 201 Created等）。

### Web架构到REST架构风格

#### 超媒体

在一个超媒体系统中，应用状态通过唯一可标识的资源的表述来表达。应用能够执行的迁移状态的标识符是以链接的形式内嵌在当前状态的表述之中的。

#### REST以及本书的其余部分

本书将Web这个术语用来描述一个更加广义的视图，而将REST这个术语留出来描述拥抱REST架构风格的解决方案。

### Web作为一个应用平台

以下的几个原因是我们选择Web作为连接分布式应用的手段：

#### 技术支持

从软件库到开发包，Web技术都被广泛地支持。

#### 可伸缩性和性能

HTTP并不是性能最好的，至少没有基于消息的协议好。但HTTP并非仅仅是另一种消息协议，它是一种实现了一些非常特殊的应用语义的协议。

#### 松耦合

Web没有试图将它的架构和技术堆栈与任何传统的QoS担保相结合，例如数据一致性、事务性、引用完整性、安全性等等。

但是HTTP定义了响应状态代码，能够被服务用来提供发生了何事的指示，如301 Moved Permanently或者303 See Other等。

#### 业务过程

利用XHTML和Atom来将系统建模为有限状态机。一旦我们理解了过程的状态能够被建模为资源，剩下的问题就仅仅是描述这些资源之间的迁移和允许客户端在运行时在它们之中选择。

#### 一致性和统一性

Web提供的操作限制在了一个很小的集合里（GET、PUT等），使得Web拥有很高的一致性和统一性。

#### 简单性，架构的无处不在，以及影响力

传统上，分布式系统开发将重点放在以特定应用的接口和交互协议来暴露定制的行为。

Web则将重点放在少量广为人知的网络动作（那些现在很熟悉的HTTP动词）以及公共的表述格式，来为我们提供影响力。

### Web的友好性和Richardson的成熟度模型

这个成熟度模型基于一个服务对于URI、HTTP和超媒体的支持，划分出了服务成熟度的三个级别。

#### 零级服务

最基本的一级，特征为那些服务有单个的URI，并且使用单个的HTTP方法（通常是POST）。

如WS-*服务，将操作都放在了XML-RPC中描述。

#### 一级服务

使用了很多的URI，但是只使用单个HTTP动词。比如用GET，然后将操作名称和参数插入到URI中，从而导致了一些副作用。

#### 二级服务

使用了大量的可通过URI寻址的资源。这样的服务支持多个HTTP动词来暴露资源。

它通常表示的是业务实体的资源状态，能够通过网络来操作。

#### 三级服务

支持超媒体作为应用状态的引擎的观念。即，表述包含了消费者可能感兴趣的到其他资源的URI链接。这种服务通过追踪资源来引导消费者，结果是引起应用状态的转移。

### 起航

后续的文章将展示如何使用Web来作为计算机与计算机之间的通信方法。

第2章 介绍Restbucks：如何以Web风格获得一杯咖啡
------------------------------------------

作者引入Restbucks咖啡店，并希望用计算机来取代人与人之间的交互。

以下这些点需要考虑：

- 参与者和沟通：确定不同的对象，例如：消费者、收银员、咖啡师、经理以及供应商
- 边界：消费者和其他人员之间有明显的边界
- 菜单：咖啡产品和提供的选项将会在服务交互中很清楚地自我表达以及与它们的表述相关的设计决策。
- 简单的交互：订单的格式（XML/Json）、通信的机制（HTTP）、以及资源本身（通过URI来寻址）。除此之外还需要考虑通知、处理通信失败、事务、可伸缩性。
- 工具箱：选择适当的URI、识别匹配的格式、应用必要的模式来完成交互。
- Restbucks的格式：确定具体的格式细节，如可以使用[Atom协议](https://tools.ietf.org/html/rfc4287)来定义良好的语义。
- 为协议和状态迁移建模：使用超媒体来描述控制系统之间交互的协议状态机，也可以利用一些[微格式](http://microformats.org)。

第3章 基础的Web集成
------------------------------------------

### 减肥的感觉真好！

并非总是需要引入中间件来解决问题，中间件往往使得问题变得更糟糕，而使用HTTP来解决却很少令人失望过。

### 一个简单的咖啡订购系统

#### 为服务选择集成点

好的集成点往往封装着有意义的业务流程或者工作流。一般来说，我们并不想暴露出任何技术细节或者实现细节。

我们要找到这样的集成点：

- 封装一些（粗粒度的）业务概念而非低层次的技术细节
- 支持现有表现逻辑的方法，如模型-视图-控制器模式中的控制器
- 负责编排与某个领域模型交互的脚本或者工作流

避免这类集成点：

- 数据访问方法，尤其是那些事务性的数据访问方法
- 属性getter和setter方法
- 任何绑定到现有表现层的东西，如重用视图逻辑或者屏幕抓取

#### 一种简单的服务架构

我们将使用HTTP请求和响应在消费者和Restbucks之间转移信息。它可以使用任何正规开发框架的通用组件，甚至使用不同的平台进行构建。

### URI模板

在分布式系统中，服务提供者经常会提供机器可以阅读的元数据，描述客户应该如何与服务进行绑定和交互。如WSDL等。

如果使用得当，URI模板会是一个非常好的工具。如果使用不当，会增加系统之间的耦合，导致集成容易被破坏。

#### 直观URI

就是一个URI，一目了然，修改其中的参数就可以获得不同的资源。

#### 从直观URI到URI模板

利用URI模板可以解释如何替换URI中的参数。

#### 使用URI模板

URI模板的一大用途就是充作人类和机器可读的文档。

### URI隧道技术

URI隧道技术是将URI作为跨越系统边界转移信息的一种方式来使用，其做法是将信息编码到URI内部。

#### URI隧道技术是不是好办法？

它仅将HTTP当作了传输协议来使用，在遵循了的HTTP动词（GET/POST)之后，它被标记为一级服务，已经好于很多的服务，但始终不尽如人意。

### POX：基于HTTP之上的普通老式XML

#### 用XML和HTTP进行远程过程调用

POX只是将HTTP作为传输协议来使用，它也可能使用TCP协议、消息队列、甚至是SOAP来实现。

#### 继续POX！

作者分别使用.net和java实现了服务端的POX写法。

#### 客户端的POX实现

作者分别使用.net和java实现了客户端的POX写法。

### XML-RPC

XML-RPC被归入POX，尝试对在HTTP请求和响应的载荷中表示这类信息的方法进行标准化，使用不同的应用都不必发明自己的格式和实现到类型系统的映射。

### 出错时会发生什么？

POX服务在Richardson的成熟度模型中排在零级。

但因为它只是将Web作为传输协议，因此Web架构固有的可伸缩性、可靠性和健壮性，对于基于POX的解决方案来说并不存在。

虽然POX是一种比较简单的、令人感到熟悉而舒适的方法，但它像URI隧道技术一样，适用范围极为有限，因此我们通常建议：应该像躲避瘟疫一样避开POX！

第4章 CRUD式Web服务
------------------------------------------

### 将Order（订单）建模为资源

CRUD式服务在Richardson成熟度模型中位于第二级，像Amazon S3的产品就是典型的服务。

#### 建造CRUD服务

我们只需要一个具体的URI、一个URI模板、四个HTTP动词，就可以暴露给消费者简单的契约。

#### 用POST创建资源

客户端发送一个POST请求创建订单，如果服务器能够正确处理则返回201 Created，并通过Location头信息包含新建订单的URI，并在响应消息体中包含对新订单状态的确认。

如果创建失败，则返回400状态码作为响应，表示客户端发送了一笔服务器不能理解的订单。此时客户端应该尽量不要重新提交该订单，因为这同样会导致同样的400响应。

如果服务器内部遇到了错误，则会返回500状态码作为响应，此时消费者无法清楚地理解服务中所发生的事情，或者不清楚请求是否成功地创建了一笔订单，因此继续前进就有些困难。在这种情况下，消费者真正希望的是重复发送POST请求来创建一个订单。

#### 用GET读取资源状态

客户端发送一个GET请求获取订单信息，这个操作应该是可以重复的，不会改变资源的状态。如果在不同请求之间，订单的状态发生了变化，这也不影响GET请求，变化并不是GET操作产生的。

如果资源不存在则返回404状态码，在这种情况下，Restbucks的消费者应该依赖带外机制来解决问题，或者尽量重新找到他们的订单的URI。

如果服务器内部错误则返回500状态码。如果遇到500的时候，可以重复发送GET请求，直到放弃为止（并且接受将控制权移交给某些带外机制），或者等待服务重新处于可用状态，然后继续处理。

#### 用PUT更新资源

- 用POST请求创建一个由服务生成其URI标识的资源。
- 用POST请求向一个由服务生成的URI标识的集合中添加一个资源。
- 用PUT请求创建或者重写一个由客户端计算得出其URI标识的资源。

PUT请求期望能将整个资源的表述都提供给服务器，而不是只提供资源状态的变化量。（比如：一杯咖啡，将全脂牛奶换成脱脂，并不是提供全脂换成脱脂的信息，而应该直接给出一杯完整的咖啡描述）另一个相对不太常用的HTTP动词，PATCH，建议在某些情况下使用（如涉及到大量的资源表述），此时通常只提供变化量。

- 状态码200：表示服务器接收了数据，同时需要在返回值中将资源的表述返回。
- 状态码204：表示服务器接收了数据，但是不会向客户端返回返回值。
- 状态码409：表示有冲突，如客户发送了修改订单的请求，但是咖啡师已经冲好了咖啡。
- 状态码405：表示方法不允许。

PUT是具有幂等语意的一个HTTP动词（另外还有本章中讲过的GET和DELETE）。因此订购服务必须确保多次向同一笔订单发送PUT请求与只发送一次PUT请求的副作用是一样的。因为允许在失败时重复该操作，这大大简化了对于间歇出现的问题的处理和崩溃恢复。

#### 用DELETE删除资源

向某个资源发送DELETE请求，并不一定表示该资源真的被删除了，这会有很多种结果。服务可能使该资源不可从Web上访问，但其他的非Web应用仍可访问该资源并在内部维护其状态，或者彻底将该资源删除。

- 状态码204：可以用于表示删除成功，但不返回具体的值。
- 状态码200：可以用于表示删除成功，但返回被删除资源的最终状态，并在消息体中使用Content-Type和Content-Length头信息以及一个资源表述。
- 状态码404：可以表示要删除的资源不存在，但这个通常代表程序应该基于这种错误采取某种恢复策略（说明客户端拥有了一个不存在的资源）
- 状态码405：可以表示方法不允许，这样可以通过某些带外机制来处理。

GET是安全且幂等的；而PUT和DELETE是幂等的，但是不安全的；POST既不安全也不幂等。

#### 校正资源状态

可以使用ETag和If-Match/If-None-Match来解决资源冲突的问题。

比如：A、B都需要更新同一个资源，在A、B第一次GET的时候，他们都得到了一个相同的ETag，那么在A、B都发送PUT请求更新资源的时候，都强调If-Match条件，那么如果A先更新的资源，A就可以成功更新，B后更新资源的时候，因为服务端计算的新的ETag与B所保存的旧的ETag不一致，那么B就应该收到状态码412，表示预处理错误。

ETag/If-Match/If-None-Match和Last-Modified/Modified-Since/If-Unmodified-Since的功能类似，但是后者的时间格式仅精确到秒。如果采用后者，不如将后者转换成前者（如把时间戳转换成字符串，并当作一个ETag），一旦未来扩展系统的时候，精度增加了，则不需要客户端做任何修改。

任何时候，都尽可能带上ETag。但是服务不要期望因为产生了ETag，就一定能在后续请求中接收到它。

### 消费CRUD式服务

#### 基于Java的消费者

可以使用Apache Commons HTTP客户端来实现协议。

#### .NET的消费者

可以使用.NET内建的XML和HTTP类库来实现协议。

### 通过WADL自动消费服务

WADL描述了服务自身所能实现的功能以及返回值等信息，最大的作用是辅助客户端使用工具来自动生成代码，并在服务端接口变化后增强客户端代码的可维护性。

### CRUD虽好，但还可以更好

CRUD式服务其实只适合于CRUD的场景。而更高级的需求则需要更丰富的交互模型，重要的是，还要支持比CRUD所允许的更强的解耦。

为了使我们的服务从客户端解放出来，让它支持通用的分布式系统，我们需要改变对资源生命周期那种共享的、紧耦合的理解。

第5章 超媒体服务
------------------------------------------

### 超媒体原则

#### 将超媒体作为应用状态的引擎（HATEOAS）

超媒体系统的特征是：根据（与应用协议参与者交换的）资源表述中的链接进行转移。这些链接会告诉你如何使用该应用（协议）中的其他资源（比如在商品订单提交后，会给你一个支付链接，那么这个支付链接就是这里的其他资源）。

资源的当前状态由以下几项共同组成：

- 属于该资源的信息项的值
- 相关资源的链接
- 表示迁移到当前资源的未来某种可能状态的链接
- 对于将该资源与其他本地资源相关联的任何业务规则的求值结果

服务通过对与有关梓元的合法交互进行广告，强制实施了一个协议——领域应用协议（domain application protocol，或称DAP）。当消费者跟随内嵌在资源表述中的链接与被链接的资源交互时，应用的整体状态发生了变化。

#### 松耦合

超媒体的妙处在于，它既是所使用的资源表述的一部分，又允许我们以一种声明式的、即时而易于修改的风格来传达协议信息。

### 超媒体格式

超媒体驱动的分布式系统对其消费者提出的要求与Web对人类提出的要求类似，即消费者必须要发现资源并与之进行交互，从而实现应用的目标。

#### 超媒体死胡同

没有使用超媒体控件的XML常被用来在Web之间交互，它们看上去像下面这样：

```
<order xmlns="http://schemas.restbucks.com">
    <location>takeAway</location>
    <item>
        <name>latte</name>
        <quantity>1</quantity>
        <milk>whole</milk>
        <size>small</size>
    </item>
    <status>pending</status>
</order>
```

但是它们存在这样的问题：

- 没有提供任何上下文，也就是说，它没有表明业务流程的当前状态
- 也没有说明如何继续前进。例如一般订单成功后都需要付款，但是这里并没有指出。

#### URI模板和耦合

例如服务端建立一个`http://restbucks.com/payment/{order_id}`的URI模板，并将其告之客户端（就像WCF技术中使用工具生成的代理Endpoint一样）。

一旦这样做了，那么它就一定是要长期稳定的，否则就有可能破坏现有的消费者应用。

如果使用超媒体的做法，则通常只暴露一个固定的URI，如`http://restbucks.com/order`，与这个URI的资源进行交互会产生进一步的资源表述，其中包含了指向订购业务流程中涉及到的更多资源的超媒体链接。

URI模板，仍然是一个好方法，但最好仅用于内部文档和实现目的。

#### 选择一种超媒体格式

REST的超媒体原则没有指定具体的表述格式，但是要求该格式必须能够传递必要的超媒体信息。

##### 标准的超媒体格式

- Atom
- XHTML

这些格式都是一些标准的格式，但是不同的格式所面向的领域需求可能不同。如XHTML对于浏览器客户端较为友好，但是Restbucks的对象实际上是计算机，因此使用XHTML可能并不合适。

##### 特定于领域的超媒体格式

作者尝试使用下面的方式来描述一个超媒体：

```
<order xmlns="http://schemas.restbucks.com">
    <location>takeAway</location>
    <item>
        <name>latte</name>
        <quantity>1</quantity>
        <milk>whole</milk>
        <size>small</size>
    </item>
    <status>pending</status>
    <payment>https://restbucks.com/payment/1234</payment>
</order>
```

但如果这样做的话，就会引入很多类似于payment这样的标签，链接语义相同，但是协议语义不同，

更好的做法可能是使用下面的方式来描述：

```
<order xmlns="http://schemas.restbucks.com">
    <location>takeAway</location>
    <item>
        <name>latte</name>
        <quantity>1</quantity>
        <milk>whole</milk>
        <size>small</size>
    </item>
    <status>pending</status>
    <link rel="http://relations.restbuck.com/payment" href="https://restbucks.com/payment/1234/">
</order>
```

这里rel记录了payment值的含义，以便消费者理解与当前资源相关的被链接资源的作用。

#### 处理超媒体格式

##### 媒体类型

DAP中的三大组件：

- 媒体类型：（Content-Type）消费者可以根据它们来确定如何处理某一种表述，而不必事先打开载荷消息体并深入探究其内容。
- 链接关系值：描述链接资源的作用，在当前表述的上下文中表明被链接资源的作用，帮助消费者理解他们为何需要激活超媒体控件。
- HTTP惯用语：操作参与协议的资源。

##### Restbucks的媒体类型

Content-Type头信息中用来与Restbucks交互的媒体类型声明是application/vnd.restbucks+xml。其中：

- vnd：供应商
- +xml：使用XML来进行文档的格式化

##### application/xml为何不行

因为它隐藏了超媒体信息，使它变成了普通的xml，从而失去了超媒体的意义。

##### 媒体类型的设计和格式

太细的媒体类型也将产生紧密的耦合，只有一种大而全的媒体类型会增加不必要的开支。

### 契约

Web的契约完全不同于其他分布式系统的静态契约。它由很多方面组成，它的核心是媒体类型。

Contacts：

- One or more media types
- Protocol(s)
- Any additional link relation values
- HTTP communications idioms
- Entry point URI(s)

#### 契约以媒体类型为起点（One or more media types） 

媒体类型规范安排好了服务要嵌入在表述中的格式（及任何纲要）、处理模型和超媒体控件。

媒体类型：帮助我们解释和处理格式。

#### 用协议扩展契约（Protocol(s) & Any additional link relation values）

在Web上，协议是通过添加新的链接关系和处理模型来扩展媒体类型的功能的。

链接关系：帮助我们理解为何需要跟随一个链接。

#### HTTP惯用语（HTTP communications idioms）

支持所有媒体类型和协议的是HTTP的统一接口，它提供了在运行时规定契约所需的基础架构。

#### 在运行时使用契约（Entry point URI(s)）

契约是运行时在Web上制定的。契约中最后落实元素是一个（或多个）对外公布的入口点URI，这时在向消费者进行广告，使它们可以绑定到服务。

### 超媒体协议

#### Restbucks领域应用协议

Restbucks支持用DAP进行订购和付款。意思就是，提供一个统一的入口，并在每一步完成之后，告诉客户端可以进行哪些后续操作。

以资源为中心，服务实现中的任何工作流都与资源的生命周期有关，而与应用协议的生命周期无关。

> 使用PUT协议，要求完整表述整个被更新的资源，包括发送所有的资源状态和链接，但是我们通常无法要求客户端发送链接（因为链接通常是由资源表述所产生的后续动作）给服务，因此无法提供PUT语义的完整表述。取而代之的是PATCH动词，但是因为该词暂不普及，因此可以用POST来替代。

#### 用超媒体对协议进行广告

通过将媒体类型从application/xml改成application/vnd.restbucks+xml，我们为消费者提供了触发一个DAP实例的途径。此后，超媒体接管了一切，Restbucks媒体类型中的链接关系会引导消费者在业务协议中一步接着一步地走下去。

通过在每一次响应中返回可以进行后续操作的link标签，可以引导客户端完成后续的操作。

#### 动态扩展应用协议

服务调整协议的时候，只需要在返回的内容中包含新的超链接，如果不理解这些超链接的客户端，忽视即可，如果理解的，则可以使用。

#### 数据模型VS.协议超媒体

Web的模型遵守底层网络。尽可能延迟（但是不会更迟）加载信息，鼓励用户通过浏览网页——经由超媒体结构——来访问信息。如先访问了网页，再通过内嵌的图片链接等请求图片。

Web的模型将整块的业务切分成了不同的小块。决定哪部分应该被分解成独立甚至重叠的资源，这是服务的设计流程的一部分。在进行这些决策时，我们应该考虑以下几个设计因素：
- 表述的大小
- 原子性
- 信息的重要性
- 性能／可伸缩性
- 可缓存性

### 实现超媒体服务

建造一个超媒体系统与建造一个CRUD系统所需要的付出是差不多的。甚至，随着服务的成长和进化，这种付出通常会在更长时期内得到更多的回报。

### 用Java建造订购服务

#### 服务架构

使用Jersey（一种JAX-RS实现）来作为基础架构。它提供了一个对底层Web服务器的友好的编程绑定。

#### Java实现

Jersey有助于提供Web服务器上的编程抽象，但它无助于创建超媒体和DAP。

##### 资源

在Jersey中，使用各种标记来将HTTP的动作路由到不同的方法中，并使用恰当的HTTP状态码来响应。

##### 表述

定义了一个能够用于XML序列化的对象作为表述（HTTP返回值所对应的类），它包含了实际的业务对象（Order）和后续的动作（Links）。

##### 工作流活动

针对每一个工作流节点，描述后续可以完成的动作（链接）。如创建订单后，可以取消、支付、更新、查看订单。

#### 消费者端的架构

使用活动和动作来抽象服务端的对象，活动（Activity）用来描述工作流的内容，如“创建订单”是一个活动，而动作（Action）将超媒体控件和相关语义上下文封装在底层的表述中。

#### Java的消费者实现

一个方法在完成“订购并支付”的代码中，通过两个活动（“订购”、“支付”）来完成，是否“支付”，其实是来自“订购”动作完成后，底层从服务器端请求得到的超媒体中包含了“可以支付”的Link，从而决定了可以完成支付。但是“支付”这件事，是通过服务契约提前就已经告知消费方的开发者了。

### 在.NET中建造订购服务

WCF也一样具备了通信框架，但仍然不具备超媒体服务的框架。

#### Restbucks的.NET超媒体框架

创建了一种DSL语言，用于描述对资源状态迁移的管理。重点在于说清楚：

- 管理什么资源（订单）
- 资源有哪些状态（创建完成、未支付、准备中、已完成）
- 对于不同状态的资源，可以做的动作都应该调用哪些方法（如可以获取订单状态，就调用GetOrderStatus，可以更新订单就调用UpdateOrder）
- 对于不同状态的资源可以做哪些动作（对应超媒体的Links）

所以，该DSL所想表达的核心逻辑是：当你想要将资源迁移到某种状态的时候，可以用哪些HTTP方法来操作，并且后续还可以进行哪些操作（Links）。

#### .NET的实现考虑

##### 资源创建

从代码的角度，仅实现那些能够将资源迁移到某个状态的方法即可，如上文中的NewOrder，并且该方法的使用传入的HTTP载和（这里是xml），并返回合适和HTTP载和（这里是xml）。

对于后续可以执行的动作（Links），则是框架根据DSL所描述的内容进行响应。

整个资源的当前状态（如：未支付），则可以在共享的内存、缓存、数据库等地方进行维护。

##### 主要的服务逻辑

框架根据资源的状态对不同的方法（函数）进行路由。如未支付的时候，GET请求，都会被路由到GetOrderStatus中。

##### 支付

支付被当作一个独立的资源来处理，有自己的状态机（DSL描述）。

比较特别的是，在当前的例子中，“支付”对象的创建，并不是该状态机的初始状态，因为它是带外创建的。因此它一旦生成，就直接进入“等待支付”的状态。

而一旦消费者选择了支付该订单，该订单就迁移到了“准备中”的状态。它不需要用户发起HTTP请求和“订单状态机”进行交互，因此需要允许代码直接将“订单状态机”状态迁移到“准备中”。

##### 交付

在咖啡师准备完咖啡后，调用OrderPrepared方法将订单的状态更新到Ready中。当下一次订单被请求的时候，会告诉消费者可以执行“收据”相关的资源。当根据“收据”对应的语义（通过relations.restbucks.com/receipt查到）的描述消费者可以发送DELETE请求到该对象，从而完成订单。

### Ready、Set和Action

超媒体服务所需要付出的努力与建造一个CRUD服务差不多。后续将看到可伸缩性、安全性和其他更高级的协议（如发布-订阅）如何与Web和谐配合。

第6章 向外扩展
------------------------------------------

第7章 Atom联合格式
------------------------------------------

第8章 Atom发布协议
------------------------------------------

第9章 Web安全
------------------------------------------

第10章 语义
------------------------------------------

第11章 Web和WS-*协议栈
------------------------------------------

第12章 为Web建造案例
------------------------------------------