REST实战
==============

![](contents/cover.jpg)

作者：Jim Webber, Savas Parastatidis, Ian Robinson 著

李锟 余黎敏 马钧 译

第1章 将Web作为建造分布式系统的平台
------------------------------------------

### Web的架构

Web的架构中，URI和资源扮演了主要的角色，并得到Web缓存的支持以获得可伸缩性。

“404 Page Not Found”错误，这个适度的状态代码为分布式计算设置了一个新的、激进的方向：它明确地承认我们无法在所有的时间控制整个系统。

### 从资源的角度思考

从消费者的观点看，资源可以是消费者能够与之交互以达成某种目标的任何东西。

#### 资源与标识符

URI唯一标识了一个Web资源，同时使得资源在Web上是可寻址的，也能够使用一种类似HTTP的应用协议来操作。

> URL（过时的概念），是一个URI，用来表达关于与所标识的资源交互的方式的信息。比如HTTP方式通信，但并非所有的URI都需要表达特定交互协议的信息，比如URN，它有可能表达一本书的ISBN：urn:isbn:0131401602。

#### 资源表述

资源必须有至少一个标识符，以便于在Web上寻址，每个标识符与一个或多个表述相关联。一个表述，指的是某个资源在某特定时刻的状态的转化形式或视图。一个资源既可以用xml来表述也可以用纯文本来表述。

Web早期的成功依赖于类似浏览器这种代理能够正确将不同的表述以人能够识别的方式呈现给人，如浏览器可以正确显示网页、图片、音乐等信息。但这些资源表述的消费者，不仅是人，还可以是其他计算机。

#### 表述格式和URI

Rails框架的流行让类似`http://restbucks.com/order.xml`这样有明确表述要求的（`.xml`）的URI变得流行。

但更好的方式则是使用内容协商机制，通过HTTP的Accept请求头，与资源的提供者进行协商。URI对于消费者来说应该是不透明的。

#### 通信的艺术

HTTP使用动词（GET,POST,PUT……）来进行交互，同时也定义了一个响应代码的集合（例如：200 OK, 201 Created等）。

### Web架构到REST架构风格

#### 超媒体

在一个超媒体系统中，应用状态通过唯一可标识的资源的表述来表达。应用能够执行的迁移状态的标识符是以链接的形式内嵌在当前状态的表述之中的。

#### REST以及本书的其余部分

本书将Web这个术语用来描述一个更加广义的视图，而将REST这个术语留出来描述拥抱REST架构风格的解决方案。

### Web作为一个应用平台

以下的几个原因是我们选择Web作为连接分布式应用的手段：

#### 技术支持

从软件库到开发包，Web技术都被广泛地支持。

#### 可伸缩性和性能

HTTP并不是性能最好的，至少没有基于消息的协议好。但HTTP并非仅仅是另一种消息协议，它是一种实现了一些非常特殊的应用语义的协议。

#### 松耦合

Web没有试图将它的架构和技术堆栈与任何传统的QoS担保相结合，例如数据一致性、事务性、引用完整性、安全性等等。

但是HTTP定义了响应状态代码，能够被服务用来提供发生了何事的指示，如301 Moved Permanently或者303 See Other等。

#### 业务过程

利用XHTML和Atom来将系统建模为有限状态机。一旦我们理解了过程的状态能够被建模为资源，剩下的问题就仅仅是描述这些资源之间的迁移和允许客户端在运行时在它们之中选择。

#### 一致性和统一性

Web提供的操作限制在了一个很小的集合里（GET、PUT等），使得Web拥有很高的一致性和统一性。

#### 简单性，架构的无处不在，以及影响力

传统上，分布式系统开发将重点放在以特定应用的接口和交互协议来暴露定制的行为。

Web则将重点放在少量广为人知的网络动作（那些现在很熟悉的HTTP动词）以及公共的表述格式，来为我们提供影响力。

### Web的友好性和Richardson的成熟度模型

这个成熟度模型基于一个服务对于URI、HTTP和超媒体的支持，划分出了服务成熟度的三个级别。

#### 零级服务

最基本的一级，特征为那些服务有单个的URI，并且使用单个的HTTP方法（通常是POST）。

如WS-*服务，将操作都放在了XML-RPC中描述。

#### 一级服务

使用了很多的URI，但是只使用单个HTTP动词。比如用GET，然后将操作名称和参数插入到URI中，从而导致了一些副作用。

#### 二级服务

使用了大量的可通过URI寻址的资源。这样的服务支持多个HTTP动词来暴露资源。

它通常表示的是业务实体的资源状态，能够通过网络来操作。

#### 三级服务

支持超媒体作为应用状态的引擎的观念。即，表述包含了消费者可能感兴趣的到其他资源的URI链接。这种服务通过追踪资源来引导消费者，结果是引起应用状态的转移。

### 起航

后续的文章将展示如何使用Web来作为计算机与计算机之间的通信方法。

第2章 介绍Restbucks：如何以Web风格获得一杯咖啡
------------------------------------------

作者引入Restbucks咖啡店，并希望用计算机来取代人与人之间的交互。

以下这些点需要考虑：

- 参与者和沟通：确定不同的对象，例如：消费者、收银员、咖啡师、经理以及供应商
- 边界：消费者和其他人员之间有明显的边界
- 菜单：咖啡产品和提供的选项将会在服务交互中很清楚地自我表达以及与它们的表述相关的设计决策。
- 简单的交互：订单的格式（XML/Json）、通信的机制（HTTP）、以及资源本身（通过URI来寻址）。除此之外还需要考虑通知、处理通信失败、事务、可伸缩性。
- 工具箱：选择适当的URI、识别匹配的格式、应用必要的模式来完成交互。
- Restbucks的格式：确定具体的格式细节，如可以使用[Atom协议](https://tools.ietf.org/html/rfc4287)来定义良好的语义。
- 为协议和状态迁移建模：使用超媒体来描述控制系统之间交互的协议状态机，也可以利用一些[微格式](http://microformats.org)。

第3章 基础的Web集成
------------------------------------------

### 减肥的感觉真好！

并非总是需要引入中间件来解决问题，中间件往往使得问题变得更糟糕，而使用HTTP来解决却很少令人失望过。

### 一个简单的咖啡订购系统

#### 为服务选择集成点

好的集成点往往封装着有意义的业务流程或者工作流。一般来说，我们并不想暴露出任何技术细节或者实现细节。

我们要找到这样的集成点：

- 封装一些（粗粒度的）业务概念而非低层次的技术细节
- 支持现有表现逻辑的方法，如模型-视图-控制器模式中的控制器
- 负责编排与某个领域模型交互的脚本或者工作流

避免这类集成点：

- 数据访问方法，尤其是那些事务性的数据访问方法
- 属性getter和setter方法
- 任何绑定到现有表现层的东西，如重用视图逻辑或者屏幕抓取

#### 一种简单的服务架构

我们将使用HTTP请求和响应在消费者和Restbucks之间转移信息。它可以使用任何正规开发框架的通用组件，甚至使用不同的平台进行构建。

### URI模板

在分布式系统中，服务提供者经常会提供机器可以阅读的元数据，描述客户应该如何与服务进行绑定和交互。如WSDL等。

如果使用得当，URI模板会是一个非常好的工具。如果使用不当，会增加系统之间的耦合，导致集成容易被破坏。

#### 直观URI

就是一个URI，一目了然，修改其中的参数就可以获得不同的资源。

#### 从直观URI到URI模板

利用URI模板可以解释如何替换URI中的参数。

#### 使用URI模板

URI模板的一大用途就是充作人类和机器可读的文档。

### URI隧道技术

URI隧道技术是将URI作为跨越系统边界转移信息的一种方式来使用，其做法是将信息编码到URI内部。

#### URI隧道技术是不是好办法？

它仅将HTTP当作了传输协议来使用，在遵循了的HTTP动词（GET/POST)之后，它被标记为一级服务，已经好于很多的服务，但始终不尽如人意。

### POX：基于HTTP之上的普通老式XML

#### 用XML和HTTP进行远程过程调用

POX只是将HTTP作为传输协议来使用，它也可能使用TCP协议、消息队列、甚至是SOAP来实现。

#### 继续POX！

作者分别使用.net和java实现了服务端的POX写法。

#### 客户端的POX实现

作者分别使用.net和java实现了客户端的POX写法。

### XML-RPC

XML-RPC被归入POX，尝试对在HTTP请求和响应的载荷中表示这类信息的方法进行标准化，使用不同的应用都不必发明自己的格式和实现到类型系统的映射。

### 出错时会发生什么？

POX服务在Richardson的成熟度模型中排在零级。

但因为它只是将Web作为传输协议，因此Web架构固有的可伸缩性、可靠性和健壮性，对于基于POX的解决方案来说并不存在。

虽然POX是一种比较简单的、令人感到熟悉而舒适的方法，但它像URI隧道技术一样，适用范围极为有限，因此我们通常建议：应该像躲避瘟疫一样避开POX！

第4章 CRUD式Web服务
------------------------------------------

第5章 超媒体服务
------------------------------------------

第6章 向外扩展
------------------------------------------

第7章 Atom联合格式
------------------------------------------

第8章 Atom发布协议
------------------------------------------

第9章 Web安全
------------------------------------------

第10章 语义
------------------------------------------

第11章 Web和WS-*协议栈
------------------------------------------

第12章 为Web建造案例
------------------------------------------