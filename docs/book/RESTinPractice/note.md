REST实战
==============

![](contents/cover.jpg)

作者：Jim Webber, Savas Parastatidis, Ian Robinson 著

李锟 余黎敏 马钧 译

第1章 将Web作为建造分布式系统的平台
------------------------------------------

### Web的架构

Web的架构中，URI和资源扮演了主要的角色，并得到Web缓存的支持以获得可伸缩性。

“404 Page Not Found”错误，这个适度的状态代码为分布式计算设置了一个新的、激进的方向：它明确地承认我们无法在所有的时间控制整个系统。

### 从资源的角度思考

从消费者的观点看，资源可以是消费者能够与之交互以达成某种目标的任何东西。

#### 资源与标识符

URI唯一标识了一个Web资源，同时使得资源在Web上是可寻址的，也能够使用一种类似HTTP的应用协议来操作。

> URL（过时的概念），是一个URI，用来表达关于与所标识的资源交互的方式的信息。比如HTTP方式通信，但并非所有的URI都需要表达特定交互协议的信息，比如URN，它有可能表达一本书的ISBN：urn:isbn:0131401602。

#### 资源表述

资源必须有至少一个标识符，以便于在Web上寻址，每个标识符与一个或多个表述相关联。一个表述，指的是某个资源在某特定时刻的状态的转化形式或视图。一个资源既可以用xml来表述也可以用纯文本来表述。

Web早期的成功依赖于类似浏览器这种代理能够正确将不同的表述以人能够识别的方式呈现给人，如浏览器可以正确显示网页、图片、音乐等信息。但这些资源表述的消费者，不仅是人，还可以是其他计算机。

#### 表述格式和URI

Rails框架的流行让类似`http://restbucks.com/order.xml`这样有明确表述要求的（`.xml`）的URI变得流行。

但更好的方式则是使用内容协商机制，通过HTTP的Accept请求头，与资源的提供者进行协商。URI对于消费者来说应该是不透明的。

#### 通信的艺术

HTTP使用动词（GET,POST,PUT……）来进行交互，同时也定义了一个响应代码的集合（例如：200 OK, 201 Created等）。

### Web架构到REST架构风格

#### 超媒体

在一个超媒体系统中，应用状态通过唯一可标识的资源的表述来表达。应用能够执行的迁移状态的标识符是以链接的形式内嵌在当前状态的表述之中的。

#### REST以及本书的其余部分

本书将Web这个术语用来描述一个更加广义的视图，而将REST这个术语留出来描述拥抱REST架构风格的解决方案。

### Web作为一个应用平台

以下的几个原因是我们选择Web作为连接分布式应用的手段：

#### 技术支持

从软件库到开发包，Web技术都被广泛地支持。

#### 可伸缩性和性能

HTTP并不是性能最好的，至少没有基于消息的协议好。但HTTP并非仅仅是另一种消息协议，它是一种实现了一些非常特殊的应用语义的协议。

#### 松耦合

Web没有试图将它的架构和技术堆栈与任何传统的QoS担保相结合，例如数据一致性、事务性、引用完整性、安全性等等。

但是HTTP定义了响应状态代码，能够被服务用来提供发生了何事的指示，如301 Moved Permanently或者303 See Other等。

#### 业务过程

利用XHTML和Atom来将系统建模为有限状态机。一旦我们理解了过程的状态能够被建模为资源，剩下的问题就仅仅是描述这些资源之间的迁移和允许客户端在运行时在它们之中选择。

#### 一致性和统一性

Web提供的操作限制在了一个很小的集合里（GET、PUT等），使得Web拥有很高的一致性和统一性。

#### 简单性，架构的无处不在，以及影响力

传统上，分布式系统开发将重点放在以特定应用的接口和交互协议来暴露定制的行为。

Web则将重点放在少量广为人知的网络动作（那些现在很熟悉的HTTP动词）以及公共的表述格式，来为我们提供影响力。

### Web的友好性和Richardson的成熟度模型

这个成熟度模型基于一个服务对于URI、HTTP和超媒体的支持，划分出了服务成熟度的三个级别。

#### 零级服务

最基本的一级，特征为那些服务有单个的URI，并且使用单个的HTTP方法（通常是POST）。

如WS-*服务，将操作都放在了XML-RPC中描述。

#### 一级服务

使用了很多的URI，但是只使用单个HTTP动词。比如用GET，然后将操作名称和参数插入到URI中，从而导致了一些副作用。

#### 二级服务

使用了大量的可通过URI寻址的资源。这样的服务支持多个HTTP动词来暴露资源。

它通常表示的是业务实体的资源状态，能够通过网络来操作。

#### 三级服务

支持超媒体作为应用状态的引擎的观念。即，表述包含了消费者可能感兴趣的到其他资源的URI链接。这种服务通过追踪资源来引导消费者，结果是引起应用状态的转移。

### 起航

后续的文章将展示如何使用Web来作为计算机与计算机之间的通信方法。

第2章 介绍Restbucks：如何以Web风格获得一杯咖啡
------------------------------------------

作者引入Restbucks咖啡店，并希望用计算机来取代人与人之间的交互。

以下这些点需要考虑：

- 参与者和沟通：确定不同的对象，例如：消费者、收银员、咖啡师、经理以及供应商
- 边界：消费者和其他人员之间有明显的边界
- 菜单：咖啡产品和提供的选项将会在服务交互中很清楚地自我表达以及与它们的表述相关的设计决策。
- 简单的交互：订单的格式（XML/Json）、通信的机制（HTTP）、以及资源本身（通过URI来寻址）。除此之外还需要考虑通知、处理通信失败、事务、可伸缩性。
- 工具箱：选择适当的URI、识别匹配的格式、应用必要的模式来完成交互。
- Restbucks的格式：确定具体的格式细节，如可以使用[Atom协议](https://tools.ietf.org/html/rfc4287)来定义良好的语义。
- 为协议和状态迁移建模：使用超媒体来描述控制系统之间交互的协议状态机，也可以利用一些[微格式](http://microformats.org)。

第3章 基础的Web集成
------------------------------------------

### 减肥的感觉真好！

并非总是需要引入中间件来解决问题，中间件往往使得问题变得更糟糕，而使用HTTP来解决却很少令人失望过。

### 一个简单的咖啡订购系统

#### 为服务选择集成点

好的集成点往往封装着有意义的业务流程或者工作流。一般来说，我们并不想暴露出任何技术细节或者实现细节。

我们要找到这样的集成点：

- 封装一些（粗粒度的）业务概念而非低层次的技术细节
- 支持现有表现逻辑的方法，如模型-视图-控制器模式中的控制器
- 负责编排与某个领域模型交互的脚本或者工作流

避免这类集成点：

- 数据访问方法，尤其是那些事务性的数据访问方法
- 属性getter和setter方法
- 任何绑定到现有表现层的东西，如重用视图逻辑或者屏幕抓取

#### 一种简单的服务架构

我们将使用HTTP请求和响应在消费者和Restbucks之间转移信息。它可以使用任何正规开发框架的通用组件，甚至使用不同的平台进行构建。

### URI模板

在分布式系统中，服务提供者经常会提供机器可以阅读的元数据，描述客户应该如何与服务进行绑定和交互。如WSDL等。

如果使用得当，URI模板会是一个非常好的工具。如果使用不当，会增加系统之间的耦合，导致集成容易被破坏。

#### 直观URI

就是一个URI，一目了然，修改其中的参数就可以获得不同的资源。

#### 从直观URI到URI模板

利用URI模板可以解释如何替换URI中的参数。

#### 使用URI模板

URI模板的一大用途就是充作人类和机器可读的文档。

### URI隧道技术

URI隧道技术是将URI作为跨越系统边界转移信息的一种方式来使用，其做法是将信息编码到URI内部。

#### URI隧道技术是不是好办法？

它仅将HTTP当作了传输协议来使用，在遵循了的HTTP动词（GET/POST)之后，它被标记为一级服务，已经好于很多的服务，但始终不尽如人意。

### POX：基于HTTP之上的普通老式XML

#### 用XML和HTTP进行远程过程调用

POX只是将HTTP作为传输协议来使用，它也可能使用TCP协议、消息队列、甚至是SOAP来实现。

#### 继续POX！

作者分别使用.net和java实现了服务端的POX写法。

#### 客户端的POX实现

作者分别使用.net和java实现了客户端的POX写法。

### XML-RPC

XML-RPC被归入POX，尝试对在HTTP请求和响应的载荷中表示这类信息的方法进行标准化，使用不同的应用都不必发明自己的格式和实现到类型系统的映射。

### 出错时会发生什么？

POX服务在Richardson的成熟度模型中排在零级。

但因为它只是将Web作为传输协议，因此Web架构固有的可伸缩性、可靠性和健壮性，对于基于POX的解决方案来说并不存在。

虽然POX是一种比较简单的、令人感到熟悉而舒适的方法，但它像URI隧道技术一样，适用范围极为有限，因此我们通常建议：应该像躲避瘟疫一样避开POX！

第4章 CRUD式Web服务
------------------------------------------

### 将Order（订单）建模为资源

CRUD式服务在Richardson成熟度模型中位于第二级，像Amazon S3的产品就是典型的服务。

#### 建造CRUD服务

我们只需要一个具体的URI、一个URI模板、四个HTTP动词，就可以暴露给消费者简单的契约。

#### 用POST创建资源

客户端发送一个POST请求创建订单，如果服务器能够正确处理则返回201 Created，并通过Location头信息包含新建订单的URI，并在响应消息体中包含对新订单状态的确认。

如果创建失败，则返回400状态码作为响应，表示客户端发送了一笔服务器不能理解的订单。此时客户端应该尽量不要重新提交该订单，因为这同样会导致同样的400响应。

如果服务器内部遇到了错误，则会返回500状态码作为响应，此时消费者无法清楚地理解服务中所发生的事情，或者不清楚请求是否成功地创建了一笔订单，因此继续前进就有些困难。在这种情况下，消费者真正希望的是重复发送POST请求来创建一个订单。

#### 用GET读取资源状态

客户端发送一个GET请求获取订单信息，这个操作应该是可以重复的，不会改变资源的状态。如果在不同请求之间，订单的状态发生了变化，这也不影响GET请求，变化并不是GET操作产生的。

如果资源不存在则返回404状态码，在这种情况下，Restbucks的消费者应该依赖带外机制来解决问题，或者尽量重新找到他们的订单的URI。

如果服务器内部错误则返回500状态码。如果遇到500的时候，可以重复发送GET请求，直到放弃为止（并且接受将控制权移交给某些带外机制），或者等待服务重新处于可用状态，然后继续处理。

#### 用PUT更新资源

- 用POST请求创建一个由服务生成其URI标识的资源。
- 用POST请求向一个由服务生成的URI标识的集合中添加一个资源。
- 用PUT请求创建或者重写一个由客户端计算得出其URI标识的资源。

PUT请求期望能将整个资源的表述都提供给服务器，而不是只提供资源状态的变化量。（比如：一杯咖啡，将全脂牛奶换成脱脂，并不是提供全脂换成脱脂的信息，而应该直接给出一杯完整的咖啡描述）另一个相对不太常用的HTTP动词，PATCH，建议在某些情况下使用（如涉及到大量的资源表述），此时通常只提供变化量。

- 状态码200：表示服务器接收了数据，同时需要在返回值中将资源的表述返回。
- 状态码204：表示服务器接收了数据，但是不会向客户端返回返回值。
- 状态码409：表示有冲突，如客户发送了修改订单的请求，但是咖啡师已经冲好了咖啡。
- 状态码405：表示方法不允许。

PUT是具有幂等语意的一个HTTP动词（另外还有本章中讲过的GET和DELETE）。因此订购服务必须确保多次向同一笔订单发送PUT请求与只发送一次PUT请求的副作用是一样的。因为允许在失败时重复该操作，这大大简化了对于间歇出现的问题的处理和崩溃恢复。

#### 用DELETE删除资源

向某个资源发送DELETE请求，并不一定表示该资源真的被删除了，这会有很多种结果。服务可能使该资源不可从Web上访问，但其他的非Web应用仍可访问该资源并在内部维护其状态，或者彻底将该资源删除。

- 状态码204：可以用于表示删除成功，但不返回具体的值。
- 状态码200：可以用于表示删除成功，但返回被删除资源的最终状态，并在消息体中使用Content-Type和Content-Length头信息以及一个资源表述。
- 状态码404：可以表示要删除的资源不存在，但这个通常代表程序应该基于这种错误采取某种恢复策略（说明客户端拥有了一个不存在的资源）
- 状态码405：可以表示方法不允许，这样可以通过某些带外机制来处理。

GET是安全且幂等的；而PUT和DELETE是幂等的，但是不安全的；POST既不安全也不幂等。

#### 校正资源状态

可以使用ETag和If-Match/If-None-Match来解决资源冲突的问题。

比如：A、B都需要更新同一个资源，在A、B第一次GET的时候，他们都得到了一个相同的ETag，那么在A、B都发送PUT请求更新资源的时候，都强调If-Match条件，那么如果A先更新的资源，A就可以成功更新，B后更新资源的时候，因为服务端计算的新的ETag与B所保存的旧的ETag不一致，那么B就应该收到状态码412，表示预处理错误。

ETag/If-Match/If-None-Match和Last-Modified/Modified-Since/If-Unmodified-Since的功能类似，但是后者的时间格式仅精确到秒。如果采用后者，不如将后者转换成前者（如把时间戳转换成字符串，并当作一个ETag），一旦未来扩展系统的时候，精度增加了，则不需要客户端做任何修改。

任何时候，都尽可能带上ETag。但是服务不要期望因为产生了ETag，就一定能在后续请求中接收到它。

### 消费CRUD式服务

#### 基于Java的消费者

可以使用Apache Commons HTTP客户端来实现协议。

#### .NET的消费者

可以使用.NET内建的XML和HTTP类库来实现协议。

### 通过WADL自动消费服务

WADL描述了服务自身所能实现的功能以及返回值等信息，最大的作用是辅助客户端使用工具来自动生成代码，并在服务端接口变化后增强客户端代码的可维护性。

### CRUD虽好，但还可以更好

CRUD式服务其实只适合于CRUD的场景。而更高级的需求则需要更丰富的交互模型，重要的是，还要支持比CRUD所允许的更强的解耦。

为了使我们的服务从客户端解放出来，让它支持通用的分布式系统，我们需要改变对资源生命周期那种共享的、紧耦合的理解。

第5章 超媒体服务
------------------------------------------

### 超媒体原则

#### 将超媒体作为应用状态的引擎（HATEOAS）

超媒体系统的特征是：根据（与应用协议参与者交换的）资源表述中的链接进行转移。这些链接会告诉你如何使用该应用（协议）中的其他资源（比如在商品订单提交后，会给你一个支付链接，那么这个支付链接就是这里的其他资源）。

资源的当前状态由以下几项共同组成：

- 属于该资源的信息项的值
- 相关资源的链接
- 表示迁移到当前资源的未来某种可能状态的链接
- 对于将该资源与其他本地资源相关联的任何业务规则的求值结果

服务通过对与有关梓元的合法交互进行广告，强制实施了一个协议——领域应用协议（domain application protocol，或称DAP）。当消费者跟随内嵌在资源表述中的链接与被链接的资源交互时，应用的整体状态发生了变化。

#### 松耦合

超媒体的妙处在于，它既是所使用的资源表述的一部分，又允许我们以一种声明式的、即时而易于修改的风格来传达协议信息。

### 超媒体格式

超媒体驱动的分布式系统对其消费者提出的要求与Web对人类提出的要求类似，即消费者必须要发现资源并与之进行交互，从而实现应用的目标。

#### 超媒体死胡同

没有使用超媒体控件的XML常被用来在Web之间交互，它们看上去像下面这样：

```
<order xmlns="http://schemas.restbucks.com">
    <location>takeAway</location>
    <item>
        <name>latte</name>
        <quantity>1</quantity>
        <milk>whole</milk>
        <size>small</size>
    </item>
    <status>pending</status>
</order>
```

但是它们存在这样的问题：

- 没有提供任何上下文，也就是说，它没有表明业务流程的当前状态
- 也没有说明如何继续前进。例如一般订单成功后都需要付款，但是这里并没有指出。

#### URI模板和耦合

例如服务端建立一个`http://restbucks.com/payment/{order_id}`的URI模板，并将其告之客户端（就像WCF技术中使用工具生成的代理Endpoint一样）。

一旦这样做了，那么它就一定是要长期稳定的，否则就有可能破坏现有的消费者应用。

如果使用超媒体的做法，则通常只暴露一个固定的URI，如`http://restbucks.com/order`，与这个URI的资源进行交互会产生进一步的资源表述，其中包含了指向订购业务流程中涉及到的更多资源的超媒体链接。

URI模板，仍然是一个好方法，但最好仅用于内部文档和实现目的。

#### 选择一种超媒体格式

REST的超媒体原则没有指定具体的表述格式，但是要求该格式必须能够传递必要的超媒体信息。

##### 标准的超媒体格式

- Atom
- XHTML

这些格式都是一些标准的格式，但是不同的格式所面向的领域需求可能不同。如XHTML对于浏览器客户端较为友好，但是Restbucks的对象实际上是计算机，因此使用XHTML可能并不合适。

##### 特定于领域的超媒体格式

作者尝试使用下面的方式来描述一个超媒体：

```
<order xmlns="http://schemas.restbucks.com">
    <location>takeAway</location>
    <item>
        <name>latte</name>
        <quantity>1</quantity>
        <milk>whole</milk>
        <size>small</size>
    </item>
    <status>pending</status>
    <payment>https://restbucks.com/payment/1234</payment>
</order>
```

但如果这样做的话，就会引入很多类似于payment这样的标签，链接语义相同，但是协议语义不同，

更好的做法可能是使用下面的方式来描述：

```
<order xmlns="http://schemas.restbucks.com">
    <location>takeAway</location>
    <item>
        <name>latte</name>
        <quantity>1</quantity>
        <milk>whole</milk>
        <size>small</size>
    </item>
    <status>pending</status>
    <link rel="http://relations.restbuck.com/payment" href="https://restbucks.com/payment/1234/">
</order>
```

这里rel记录了payment值的含义，以便消费者理解与当前资源相关的被链接资源的作用。

#### 处理超媒体格式

##### 媒体类型

DAP中的三大组件：

- 媒体类型：（Content-Type）消费者可以根据它们来确定如何处理某一种表述，而不必事先打开载荷消息体并深入探究其内容。
- 链接关系值：描述链接资源的作用，在当前表述的上下文中表明被链接资源的作用，帮助消费者理解他们为何需要激活超媒体控件。
- HTTP惯用语：操作参与协议的资源。

##### Restbucks的媒体类型

Content-Type头信息中用来与Restbucks交互的媒体类型声明是application/vnd.restbucks+xml。其中：

- vnd：供应商
- +xml：使用XML来进行文档的格式化

##### application/xml为何不行

因为它隐藏了超媒体信息，使它变成了普通的xml，从而失去了超媒体的意义。

##### 媒体类型的设计和格式

太细的媒体类型也将产生紧密的耦合，只有一种大而全的媒体类型会增加不必要的开支。

### 契约

Web的契约完全不同于其他分布式系统的静态契约。它由很多方面组成，它的核心是媒体类型。

Contacts：

- One or more media types
- Protocol(s)
- Any additional link relation values
- HTTP communications idioms
- Entry point URI(s)

#### 契约以媒体类型为起点（One or more media types） 

媒体类型规范安排好了服务要嵌入在表述中的格式（及任何纲要）、处理模型和超媒体控件。

媒体类型：帮助我们解释和处理格式。

#### 用协议扩展契约（Protocol(s) & Any additional link relation values）

在Web上，协议是通过添加新的链接关系和处理模型来扩展媒体类型的功能的。

链接关系：帮助我们理解为何需要跟随一个链接。

#### HTTP惯用语（HTTP communications idioms）

支持所有媒体类型和协议的是HTTP的统一接口，它提供了在运行时规定契约所需的基础架构。

#### 在运行时使用契约（Entry point URI(s)）

契约是运行时在Web上制定的。契约中最后落实元素是一个（或多个）对外公布的入口点URI，这时在向消费者进行广告，使它们可以绑定到服务。

### 超媒体协议

#### Restbucks领域应用协议

Restbucks支持用DAP进行订购和付款。意思就是，提供一个统一的入口，并在每一步完成之后，告诉客户端可以进行哪些后续操作。

以资源为中心，服务实现中的任何工作流都与资源的生命周期有关，而与应用协议的生命周期无关。

> 使用PUT协议，要求完整表述整个被更新的资源，包括发送所有的资源状态和链接，但是我们通常无法要求客户端发送链接（因为链接通常是由资源表述所产生的后续动作）给服务，因此无法提供PUT语义的完整表述。取而代之的是PATCH动词，但是因为该词暂不普及，因此可以用POST来替代。

#### 用超媒体对协议进行广告

通过将媒体类型从application/xml改成application/vnd.restbucks+xml，我们为消费者提供了触发一个DAP实例的途径。此后，超媒体接管了一切，Restbucks媒体类型中的链接关系会引导消费者在业务协议中一步接着一步地走下去。

通过在每一次响应中返回可以进行后续操作的link标签，可以引导客户端完成后续的操作。

#### 动态扩展应用协议

服务调整协议的时候，只需要在返回的内容中包含新的超链接，如果不理解这些超链接的客户端，忽视即可，如果理解的，则可以使用。

#### 数据模型VS.协议超媒体

Web的模型遵守底层网络。尽可能延迟（但是不会更迟）加载信息，鼓励用户通过浏览网页——经由超媒体结构——来访问信息。如先访问了网页，再通过内嵌的图片链接等请求图片。

Web的模型将整块的业务切分成了不同的小块。决定哪部分应该被分解成独立甚至重叠的资源，这是服务的设计流程的一部分。在进行这些决策时，我们应该考虑以下几个设计因素：
- 表述的大小
- 原子性
- 信息的重要性
- 性能／可伸缩性
- 可缓存性

### 实现超媒体服务

建造一个超媒体系统与建造一个CRUD系统所需要的付出是差不多的。甚至，随着服务的成长和进化，这种付出通常会在更长时期内得到更多的回报。

### 用Java建造订购服务

#### 服务架构

使用Jersey（一种JAX-RS实现）来作为基础架构。它提供了一个对底层Web服务器的友好的编程绑定。

#### Java实现

Jersey有助于提供Web服务器上的编程抽象，但它无助于创建超媒体和DAP。

##### 资源

在Jersey中，使用各种标记来将HTTP的动作路由到不同的方法中，并使用恰当的HTTP状态码来响应。

##### 表述

定义了一个能够用于XML序列化的对象作为表述（HTTP返回值所对应的类），它包含了实际的业务对象（Order）和后续的动作（Links）。

##### 工作流活动

针对每一个工作流节点，描述后续可以完成的动作（链接）。如创建订单后，可以取消、支付、更新、查看订单。

#### 消费者端的架构

使用活动和动作来抽象服务端的对象，活动（Activity）用来描述工作流的内容，如“创建订单”是一个活动，而动作（Action）将超媒体控件和相关语义上下文封装在底层的表述中。

#### Java的消费者实现

一个方法在完成“订购并支付”的代码中，通过两个活动（“订购”、“支付”）来完成，是否“支付”，其实是来自“订购”动作完成后，底层从服务器端请求得到的超媒体中包含了“可以支付”的Link，从而决定了可以完成支付。但是“支付”这件事，是通过服务契约提前就已经告知消费方的开发者了。

### 在.NET中建造订购服务

WCF也一样具备了通信框架，但仍然不具备超媒体服务的框架。

#### Restbucks的.NET超媒体框架

创建了一种DSL语言，用于描述对资源状态迁移的管理。重点在于说清楚：

- 管理什么资源（订单）
- 资源有哪些状态（创建完成、未支付、准备中、已完成）
- 对于不同状态的资源，可以做的动作都应该调用哪些方法（如可以获取订单状态，就调用GetOrderStatus，可以更新订单就调用UpdateOrder）
- 对于不同状态的资源可以做哪些动作（对应超媒体的Links）

所以，该DSL所想表达的核心逻辑是：当你想要将资源迁移到某种状态的时候，可以用哪些HTTP方法来操作，并且后续还可以进行哪些操作（Links）。

#### .NET的实现考虑

##### 资源创建

从代码的角度，仅实现那些能够将资源迁移到某个状态的方法即可，如上文中的NewOrder，并且该方法的使用传入的HTTP载和（这里是xml），并返回合适和HTTP载和（这里是xml）。

对于后续可以执行的动作（Links），则是框架根据DSL所描述的内容进行响应。

整个资源的当前状态（如：未支付），则可以在共享的内存、缓存、数据库等地方进行维护。

##### 主要的服务逻辑

框架根据资源的状态对不同的方法（函数）进行路由。如未支付的时候，GET请求，都会被路由到GetOrderStatus中。

##### 支付

支付被当作一个独立的资源来处理，有自己的状态机（DSL描述）。

比较特别的是，在当前的例子中，“支付”对象的创建，并不是该状态机的初始状态，因为它是带外创建的。因此它一旦生成，就直接进入“等待支付”的状态。

而一旦消费者选择了支付该订单，该订单就迁移到了“准备中”的状态。它不需要用户发起HTTP请求和“订单状态机”进行交互，因此需要允许代码直接将“订单状态机”状态迁移到“准备中”。

##### 交付

在咖啡师准备完咖啡后，调用OrderPrepared方法将订单的状态更新到Ready中。当下一次订单被请求的时候，会告诉消费者可以执行“收据”相关的资源。当根据“收据”对应的语义（通过relations.restbucks.com/receipt查到）的描述消费者可以发送DELETE请求到该对象，从而完成订单。

### Ready、Set和Action

超媒体服务所需要付出的努力与建造一个CRUD服务差不多。后续将看到可伸缩性、安全性和其他更高级的协议（如发布-订阅）如何与Web和谐配合。

第6章 向外扩展
------------------------------------------

### 回到基础

对于安全的和幂等的GET请求来说，将响应保存在接近消费者的地方是有意义的，可以被后续的请求反复使用。

#### 缓存

缓存指的是这样一种能力：能够沿着请求-响应的路径将经常存取的数据保存在多个地方。当消费者请求一个资源的表述时，请求先检查存放这个资源的主机上一个或一系列缓存。如果沿着请求路径上的缓存中存在着资源表述的最新副本，就用这个副本去满足请求；如果没有缓存能满足请求，那么请求将会被交给服务来处理（正式的名称是来源服务器（origin server））。

来源服务器控制它们所发布的表述的缓存行为。

包括对缓存添加一个Age响应头信息。

#### 缓存的益处

- 减少带宽
- 降低延迟
- 减轻服务器的负载
- 隐藏网络故障 - 即使来源服务器出现故障，缓存仍然能够继续提供已缓存的内容。

#### 缓存和无状态约束

无状态约束（是Web关键架构原则之一）有自己的缺点：

- 增加了消息的大小和带宽消耗，消费者和服务必须在每次请求和响应时交换应用的状态信息。
- 不能使用经典的“发布-订阅”模式，因为无状态约束要求服务在请求之间将客户（请求者）忘记。

缓存有助于减轻应用无状态约束的后果。

#### 不做缓存的理由

至少有以下四种情况可能我们不需要缓存：

- GET请求在服务器端产生了对服务有业务影响的副作用。如日志、请求计数等行为。
- 消费者无法容忍响应传回的资源状态和在满足请求时刻该资源当前实际状态之间的差异。
- 响应包含了某些特定于消费者的敏感的或个人的数据。
- 数据变化频繁，导致缓存和重新验证响应的开销反而高于来源服务器只是简单为每个请求生成一个新的响应。

#### 缓存的类型

- 本地缓存，本地计算机的内存、磁盘等地方。
- 代理缓存，用于加速访问Web资源。
- 反向代理，位于应用或者Web服务器的前面。反向代理集群增加了冗余、防止热门的资源成为服务器的性能热点。包括[Squid](http://www.squid-cache.org)、[Varnish](http://www.varnish-cache.org)和[Apache Traffic Server](http://trafficserver.apache.org)

### 创建可缓存的内容

- GET请求的响应默认是可缓存的。
- POST请求的响应默认是不可缓存的，但如果响应包含明确允许缓存的Expires头信息或者Cache-Control头信息，那么它还是可以被缓存的。
- PUT请求的响应总是不可缓存的。
- DELETE请求的响应总是不可缓存的。

#### 为缓存使用响应头信息

- Expires：过期时间，可以设置为和Date一样的值或者0表示已经过期（不缓存），也可以设置一年以后来标记为可以缓存。
- Cache-Control：可以设置各种指令表示缓存行为，如可以设置max-age或者s-maxage表明相对的生存时间
- ETag：在验证被缓存表述的新鲜度（freshness）方面也同样有用。
- Last-modified：Date头表示响应何时生成，而Last-modified表示相关联的资源最后是在何时修改的。Last-modified值不能晚于Date值。

#### 在响应中使用缓存指令

- max-age：它可以使用本地缓存和共享缓存来缓存，以秒为单位
- s-maxage：仅可使用共享缓存来缓存，以秒为单位
- public：使用本地缓存或共享缓存。它优先于Authorization头信息，也就是一些身份认证后的响应，如果遇到了public仍然会被缓存。
- private：只能使用本地缓存。
- must-revalidate：使通常不可缓存的响应可以被缓存，但是需要缓存重新到来源服务器上去验证一下过期的响应。
- proxy-revalidate：与must-revalidate一样，但只适用于共享缓存。
- no-cache：要求缓存为每个请求都到来源服务器上重新验证已缓存的响应。如果请求成功地被来源服务器验证，那么缓存的内容可以被用来满足这个请求。
- no-store：所有的缓存（本地缓存、代理缓存、反向代理缓存）不将通常可以被缓存的内容缓存起来。
- stale-while-revalidate：先返回响应，再去来源服务器确认是否需要更新缓存。
- stale-if-error：先去来源服务器确认，如果发生了错误，就用缓存的内容先应付一下。

### 在.NET中实现缓存

消费者侧使用本地缓存，如增加RequestCacheLevel.Default来支持。

来源提供者，添加Cache-Control为public, max-age=604800来表示一周内缓存都有效。

#### 一致性

缓存只会加剧不一致性。在我们引入缓存的那个时刻，我们应假设消费者会同服务发生不一致的状况，并且能够处理它。

下面三种技术可以用来增强一致性：

- 失效
- 验证
- 到期

#### 使用验证

使用类似ETag的标记来和来源服务器进行验证，从而利用缓存。

#### 使用到期

使用一些Cache-Control指令允许消费者在一致性和延迟之间作出权衡。

#### 使用失效

- 消费者驱动的失效：HTTP固有的，但它无法避免弱一致性。
- 服务器驱动的失效：不属于HTTP固有的功能，是指服务发送失效通知给缓存和消费者，但是这通常对Web不友好，因此到期和验证是目前在Web上确保服务和消费者之间一致性的最常用方法。

#### 延长保鲜寿命

当我们在决定一个表述的保鲜寿命时，必须在服务器的可控性和可伸缩性之间作出平衡。

#### 缓存通道

缓存通道通过在Cache-Control提供扩展指令channel和group来提供缓存机制，缓存会定期从channel所指定的URI中确认缓存表述是否过期，如果未过期，就保持缓存的内容仍然可用，否则则停止更新缓存的过期时间，直到下一次请求缓存的时候，缓存将到来源服务器重新验证这个过期的表述。

缓存通道与Web配合工作，它们不需要来源服务器以已连接缓存列表的形式来维护应用的状态。每个缓存通过轮询缓存通道来确保接收到过期事件。

缓存通道是Mark Nottingham首创的，参见他的blog：[Cache Control](https://www.mnot.net/blog/2008/01/04/cache_channels)，以及已经过期的RFC草稿[HTTP Cache Channels](http://ietfreport.isoc.org/idref/draft-nottingham-http-cache-channels/)

### 保持新鲜

无论我们采用到期机制还是验证机制，我们必须始终记住，我们无法保证消费者收到一个资源状态的表述同服务所持有的资源的当前状态一致。

第7章 Atom联合格式
------------------------------------------

Atom是一种基于XML的超媒体格式，用于表现Web内容的时间戳列表以及诸如blog发表和新闻文章这样的元数据。

### 格式

Atom规范（[RFC4287](http://www.ietf.org/rfc/rfc4287.txt)）定义了Atom文档的结构。但是提要（feed）的具体内容会根据我们的应用领域的需求而变化。

Atom用各种元数据元素来表现与资源的发布生命周期相关的信息：作者、创建日期、最后修改时间等等。

#### Atom的一般用途

- 联合内容
- 表述文档和文档类似的结构：很多领域的资源时类似文档这样被结构化的，它们可以直接使用Atom的元数据元素。
- 创建元数据丰富的资源列表
- 在现有的资源表述上添加元数据
- 创建非超媒体内容的目录

### 将Atom用于事件驱动系统

#### 存在的问题

支持关键业务流程的系统需要访问位于其他位置的数据。

- 可能需要共享数据
- 也可能需要提供一个单一的、一致性的业务资源视图

#### 参考数据

寻找和使用参考数据时两个完全不同的问题。

为了降低耦合性，应该将寻找和使用参考数据分离开，简单的说，就是不能在每次需要使用数据的时候就去调用另一个服务，这样耦合性就很高。应该是参考数据的拥有者发布数据的副本，让消费者可以缓存它们。消费者使用这些参考数据的本地副本来运作，直到它们过期。

#### 事件驱动的更新

为了将产品目录服务中数据变更通知到其他系统，可以实现一个事件驱动的架构。一旦有新的数据变化，产品目录都会发布一个事件。其他系统接收这些事件并更新它。

其他系统通过轮询产品目录的Atom提要来接收更新。

Web系统的缓存可以降低频繁轮询带来的单点压力。

#### 事件剖析

所谓事件，是指特定时间点的某个资源的状态发生了重大变化。一个事件承载了重要的元数据，包括事件类型、发生的日期和时间，以及触发事件的系统或人的名称。

#### 解决方案概述

- 工作提要：包含了所有过去的某个分界点到现在为止发生的事件。（它的URL通常和归档提要类似，只是它一直在变，比如当前工作提要是：http://xxx/2017/03/26）
- 归档提要：包含了所有在分界点之前发生的事件。
- 最近事件提要：它不是一个历史提要，它总是最新的。（它的URL通常是一个固定值，它的内容在当前时间点和工作提要一致，但是它始终是类似：http://xxx/latest）

#### 链接关系

[IANA链接关系注册表（Registry of Link Relations）](https://www.iana.org/assignments/link-relations/link-relations.xhtml),包含了一个经过认证的链接关系值的冗长列表。它们都可以用作`rel`的值。

Atom规范描述了5类链接关系：self、via、alternate、enclosure、related。

#### 轮询最近事件

产品通知列表的所有消费者都要以最近事件提要为切入点。

atom:link中的rel=prev-archive链接关系值由提要分页和归档规范[Feed Paging and Archiving](https://tools.ietf.org/html/rfc5005)来定义。

#### 遍历归档提要

客户端会先从提要中找到之前已经处理过的atom:id值对应的内容，然后从这个点开始往后处理。如果找不到这个id值，就访问`link rel=prev-archive`所指向的提要内容。

#### 缓存提要

由于遍历的过程可能穿越多次http请求，当找到上次处理条目后，再次往后走，因此可能会重复调用之前已经请求过的http链接，因此，对这些存档链接进行缓存将大大提高性能。

#### 实现时的注意事项

工作提要仅仅在很短的时间内被缓存，而归档提要则能够长期被缓存。

- `<atom:id>`和`<atom:updated>`来标识距离现在最久的需要处理的条目
- Categories用于进一步细化需要处理的条目列表
- related链接将条目与特定于领域的资源相互关联
- 条目的`<atom:content>`元素的type属性值来确定适用于特定领域表述的处理模型

### 用Java建造Atom服务

采用了[ROME](https://github.com/rometools/rome)来生成和消费Atom提要，使用Grizzly Web服务器，以及Jersey来提供服务和消费者的HTTP基础架构。

#### 服务器端架构

一共分成5层：

- Web Server（Grizzly）：组成了网络访问接口
- HTTP Layer（JAX-RS）：组成了网络访问接口，将提要发送到Web。
- Atom Layer（ROME）：生成提要，是通过ROME库来查询和将适当的事件从领域模型推送到提要对象的操作。
- Domain Objects：封装了仓库信息，并且将其提供给上一层
- Event Repository：保存着产品和促销活动变更历史

#### 管理提要

服务的消费者沿着next-archive和prev-archive链接遍历提要，并不需要关心具体的URI格式。URI对于消费者来说是不透明的，是链接关系（而不是URI）在驱动协议的运转。

#### Java实现

##### 使用Jersey提供HTTP连通性

通过解析`/recent`，提供了最近事件提要列表，并设定了缓存的时间。Jersey只是提供了HTTP级别的访问，具体的Atom由ROME来生成。

##### 用ROME生成提要

用ROME来生成提要，通过对self、via、related、prev-archive、next-archive等描述，使得提要之间可以相互关联和遍历。

##### Java消费者实现

消费者的代码不包含任何业务逻辑和出错处理。使用ROME的WireFeedInput类将Atom提要作为字符串实例提取出来，传递给ROME库，在那里它被转换成一个能够被消费者业务逻辑处理的对象表述。

在没有找到上一次的保存的提要条目的时候，需要沿着prev-archive链接寻找。

### 在.NET中创建Atom服务

.NET解决方案提供从文件系统中预先生成的Atom提要，而不是去动态构造提要。

#### 将提要写入文件

为了让最近事件提要不会产生读写冲突，不对同一个最近事件提要文件进行更改，而是在内存中维护一个映射，每次更新最近事件提要的时候，创建一个最近事件提要的副本，在未更新完成之前，内存中的映射指向旧的文件，更新完成后，将内存中的映射指向新文件。

#### 任务

用一个事件的处理管道将最近事件提要的任务都组织起来。这些任务从事件缓冲区中获取数批新事件并且更新最近事件提要。

#### 建造提要

FeedBuilder创建提要和条目在内存中的表述。提要有两种类型：RecentEventsFeed和ArchiveFeed。提要建造器负责创建新的最近事件提要，并将它们保存到文件系统中。它还可以创建一个后续提要，也可以创建当前提要的归档提要。

#### 处理请求

首先，从仓库中取出一个表述。然后它将这个表述提供给请求中指定的条件。这个条件创建并返回一个响应，该响应被传递给主机应用于响应流。

#### 编写响应

使用decorator模式，为WorkingFeed、FeedOfRecentEvents、ArchiveFeed、FileBasedAtomDocument响应增加各种HTTP头信息，用于控制缓存等。

#### 实现条件GET请求

为响应添加ETag以满足后续请求中发过来的If-None-Match头信息。

#### 总装

提要书写者和通知服务运行在同一个进程的不同线程之中。它们之间唯一需要同步的时候，是在提要书写者更新最近事件提要时。当这个发生时，通知服务需要知道与最近事件提要相关联的新的临时文件名。

为此，提要书写者暴露一个FeedMappingsChanged事件。当NotifyingListener任务调用notifyMappingChanged参数委托时会触发这个事件。

### Atom无处不在？

下面的场景并不是选择Atom的理由：
- 为了实现跨平台的场景
- 如果只需要一个列表，而不是提要元数据
- 填充Atom元数据元素的数据对客户其实没用

Atom的扩展性：
- 通过属性扩展（元数据扩展）：将普遍适用且与应用无关的元数据添加到提要。
- 通过附加元素扩展（元数据扩展）：同上
- 内容扩展性：将私有信息存放在条目的`<atom:content>`元素中。

### 反思

使用Atom为Restbucks开发了一个事件驱动系统以传播产品信息、传播通知、借助缓存分担负载等，使得它被认为在Richardson成熟度模型中位于第三级（最高级）。

第8章 Atom发布协议
------------------------------------------

[Atom发布协议](https://tools.ietf.org/html/rfc5023)，一个建立在Atom之上的协议，用于发布和编辑Web资源。

### Atom发布协议

AtomPub是一种用于发布和编辑包含相关的Atom元数据的Web内容（包括二进制内容）的领域应用协议。

#### 概述

AtomPub：一个发布和编辑Web资源的应用层协议……基于HTTP对Atom格式表述的转移来实现。
- 这是一个应用层协议
- 这是为发布和编辑Web内容而设计的
- 这是基于HTTP对Atom格式表述的转移

#### 何时使用AtomPub

我们建议在以下场景中使用AtomPub：
- 创建和操作Atom条目
- 将Atom元数据关联到已发布的Web资源
- 发展一个可互操作的发布协议
- 支撑一个领域应用协议

#### 剖析AtomPub

Atom的处理模型定义了建造超媒体应用的4个关键点：
- 资源表述的格式
- 超媒体控件的标记
- 客户可以用来操作资源的HTTP惯用语
- 服务器用来对合法的状态迁移进行广告的链接关系

AtomPub的动态部分包含了4个资源——成员、集合、服务文档和分类文档——以及它们的表述格式。

其中服务文档作为一个进入服务所包含集合对外公布的入口点。客户可以从一个服务文档遍历服务所提供的集合。

#### AtomPub对Atom的扩展

AtomPub通过几种方式来扩展Atom：
- 使用Atom的扩展性添加了三个条目的元素`<app:edited>`、`<app:control>`、`<app:draft>`。这三个元素属于AtomPub命名空间。
- 添加了两个新的链接关系值到IANA的链接关系注册表中：`edit`和`edit-media`。
- 添加了一个type参数到Atom媒体类型。type参数的引入是为了迎合不同的客户处理能力。

#### 并发控制

使用ETag和If-Match来控制PUT指令的时候，没有发生[丢失更新](https://www.w3.org/1999/04/Editing/)。

### 使用AtomPub实现订单履行

本节分步描述了订单履行的过程，重点在于每次调整订单状态都会使用ETag和If-Match来防止冲突，从而实现了使用AtomPub在多个角色之间的状态转移。具体的过程请参看原书。

#### 实现更复杂的协议

之前的示例对单一条目进行变更以控制整个结果。这一节通过扩展协议，增加了一个“已履行订单”集合，并在咖啡师决定履行某个订单后将这个订单POST给“已履行订单”集合，从而实现了订单履行的过程。

### 在.NET中实现AtomPub

这一节使用WCF实现了订单履行的过程。

### 一个多功能的协议

AtomPub解决了存在于很多公共的发布用例中的问题，尽管其编程支持不如Atom那样普及，但它仍然是一个被广泛采用、可互操作的发布协议。当我们需要为Web资源集合实现发布功能时，AtomPub应该是优先考虑的协议。

第9章 Web安全
------------------------------------------

安全计算的四个核心支柱：
- 机密性：确保信息在传输或存储时的私密性的能力。
- 完整性：防止信息在未被检测到的情况下遭到篡改的能力。
- 身份标识性：对参与交互的各方做身份认证的能力。
- 可信任性：授权对方按指定方式与系统进行交互。

### HTTP安全要点

#### HTTP身份认证和授权
- HTTP Basic身份认证：较为不安全 https://www.w3.org/Protocols/HTTP/1.0/spec.html#BasicAA
- HTTP Digest身份认证：较为安全，但仍需要传输层的保护 http://www.ietf.org/rfc/rfc2617.txt
- WSSE身份认证：较为安全，但仍需要传输层的保护 https://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0.pdf

#### 传输层的机密性和完整性

使用HTTPS可以获得很好的安全性。

#### 网络和性能方面的考虑

使用安全通道（HTTPS）的问题：
- 加密成本提高
- 阻止了网络中（中间组件）的缓存发挥作用（可以使用消费端缓存）

作为服务的开发人员，应该在安全性和可伸缩性之间作出权衡，并根据资源的风险性和性能要求来决定哪些资源需要被保护。

### 身份标识和OpenID协议

持续对消费者进行跟踪是一个难题，但是它不应该是业务服务提供者所承担的问题。相反，我们应该将身份管理委派给专门的服务，它知道如何将身份管理做得更好。

#### 协议流程

> 原文详细描述了OpenID的认证过程，建议翻阅原书。

OpenID是一个以Web为中心的协议。它使用URI作为消费者的身份声明的基础，使用超媒体（XHTML表单和POST数据）将协议的步骤捆绑在一起。

因为所有的强制性的通信都是通过消费者发起，所以这个协议中OpenID提供者与依赖方（如Restbucks）之间保持了松耦合。只要服务信任它通过发现机制找到的OpenID提供者，这个协议就支持以去中心化的方式进行身份认证以及运行时发现——所有这些都是通过超媒体来驱动。

#### Java中的OpenID

OpenID的三种角色中：OpenID Provider（提供者）扮演的是匿名优惠卡的提供方、Restbucks（是依赖方）扮演咖啡提供商，依赖于提供者提供的OpenID进行优惠卡消费、顾客扮演Consumer（消费者）。

因此三种角色的代码逻辑分为以下三大块：

1. 启用OpenID的消费者的Java实现
    1. 消费者从Restbucks拿到优惠表单，填写`openid_identifier`。
    2. 将`openid_identifier`发送给Restbucks，并收到一个需要转交给OpenID的不透明信息。
    3. 将不透明信息传递给OpenID提供者。
    4. OpenID提供者返回一个登录表单给消费者，要求其提供确认身份的方式。
    5. 登录成功后，OpenID提供者返回一个不透明数据，包含是否登录成功的信息给消费者。
    6. 消费者将登录后得到的不透明数据，发给Restbucks。
2. Restbucks订单服务的Java实现
    1. 接受OpenID URI标识的客户。（对应上一个环节的步骤1：消费者从Restbucks拿到优惠表单）
    2. 与OpenID提供者创建关联。（拿到用户的`openid_identifier`后，Restbucks在后台与OpenID提供者进行发现和关联）
    3. 通过消费者与OpenID提供者进行间接通信。（对应上一个环节的步骤2、3）
    4. 如果消费者通过了认证，能将消费情况记录到对应的优惠卡中。
3. OpenID提供者的Java实现
    1. 发现（discover），提供了一个能够解释OpenID的入口。
    2. 关联（association），作者使用OpenID4J包的ServerManager的assocationResponse方法来处理。[具体可以参考这里：http://openid.net.cn/specs/openid-authentication-2_0-zh_CN.html#associations](http://openid.net.cn/specs/openid-authentication-2_0-zh_CN.html#associations)
    3. 认证（authentication），作者使用OpenID4J包的ServerManager的authResponse方法来处理。这个步骤是在消费者已经通过了身份认证之后。

#### OpenID的实践考虑

OpenID在企业中因为明确指定了OpenID的提供者，因此不存在对提供者的信任问题，因此也可以广泛应用在企业中。

### OAuth协议

OAuth协议使得服务和应用能够与第三方服务包含的安全资源进行交互，而不需要资源的拥有者将他们的身份凭证共享出来。

#### 接下来最好能有免费咖啡？

场景：假设用户不使用现金／信用卡为咖啡付费，而是采用第三方咖啡代金券提供者提供的服务，为咖啡付费，而Restbucks并不关心用户如何通过咖啡代金券提供者的认证，只需要关心收到的咖啡代金券即可。

OAuth的参与方主要有三个：

- 服务端：管理或存储资源的地方，比如银行，这个例子中是代金券提供商
- 资源拥有者：资源的事实拥有者，比如“钱其实不是银行的，是储蓄者的”，这个例子中是消费者
- 客户端：想要使用资源的人，比如你把支票给了一个人，这个例子中是Restbucks

作为客户端，Restbucks永远无法看到资源拥有者与代金券服务共享的身份凭证。

OAuth定义了三种不同的身份凭证类型：客户端凭证、临时凭证、令牌凭证。每一组凭证都包括一个唯一的标识符和一个共享的秘密（shared secret）。

#### OAuth协议范例

所有的假设都是在计算机和计算机之间完成的：

- 客户端（顾客），向代金券提供者发起GET请求，获取代金券列表。
- 客户端（顾客），挑选1张代金券，向服务器（Restbucks）发起PUT请求，表明要使用该代金券。
    - 服务器（Restbucks）收到代金券后，需要使用代金券服务来兑现代金券。
    - 服务器（Restbucks）向代金券提供者发起DELETE请求，尝试使用代金券。
    - 代金券提供者返回401表示未验证的请求，请先提供OAuth凭证我才能让你兑换。
    - 服务器（Restbucks）将它的OAuth客户端凭证向代金券服务发送POST请求，来回应质询。（包括：`oauth_signature`, `oauth_signature_method`, `oauth_timestamp`, `oauth_nonce`, `oauth_custom_key`, `oauth_callback`, `oauth_version`等）
    - 代金券提供者收到请求后，使用存储的密钥来对请求中提供的数字签名进行验证，从而决定请求是否有效。如果请求是有效的，返回一个临时凭证（`oauth_token`, `oauth_token_secret`, `oauth_callback_confirmed`）。
    - 服务器（Restbucks）存储临时秘密（`oauth_token_secret`)用于后续操作，并向客户端（顾客）响应303重定向，让顾客回到代金券提供商的页面a（参数里面带有了临时令牌`oauth_token`）。
- 客户端（顾客）收到303重定向后，向代金券提供者发起GET请求，请求中包含代金券提供者发给服务器（Restbucks）的临时令牌`oauth_token`。
    - 代金券提供者返回给客户端（顾客）一个页面a，让用户确认身份（这里需要用户输入密码）。
    - 代金券提供者收到密码后，如果验证通过，就给客户端（顾客）发送一个重定向，让顾客回到服务器（Restbucks），并包含了一个给服务器（Restbucks）的验证码（`oauth_verifier`）。
- 客户端（顾客）收到重定向请求后，向服务器（Restbucks）发送了GET请求，告诉服务器（Restbucks）验证码（`oauth_verifier`）是什么。
    - 服务端（Restbucks）收到验证码（`oauth_verifier`）后，向代金券提供者发送了POST请求，用临时秘密（`outh_token_secret`）给获取令牌的请求做签名，将临时令牌（`oauth_token`）、验证码（`oauth_verifier`）发给代金券提供者。
    - 代金券提供者收到后，验证通过，给服务器（Restbucks）发送令牌凭证（`正式oauth_token`）和令牌秘密（`正式oauth_token_secret`），这个令牌用于访问客户端（顾客）授权访问的资源，理论上可以存储并使用多次，但是本示例中，只使用一次。
    - 服务端（Restbucks）向代金券提供者发起DELETE请求，尝试使用代金券，和上次不同，这次带上了令牌凭证（`正式oauth_token`），代金券兑换成功，返回200给服务端（Restbucks）。
    - 服务端（Restbucks）收到请求后，返回200给客户端（顾客）。
- 客户端（顾客）向代金券提供者发起GET请求，查看代金券的Atom提要，检查虚拟钱包的状态，代金券是否已经被兑换了。

### OAuth的Java实现

第10章 语义
------------------------------------------

第11章 Web和WS-*协议栈
------------------------------------------

第12章 为Web建造案例
------------------------------------------