微服务设计（Building Microservices）
========================================

[英]Sam Newman著

崔力强 张骏 译

第1章 微服务
---------------------

微服务的诞生离不开下面这些技术实践的发展，而这些技术在10年前几乎是很难想象的：

| 实践类型      |    作用/现象                                            |
|:------------:|:-----------------------------------------------------:|
| 领域驱动设计   | 帮助理解用代码呈现真实世界的重要性、告诉我们如何更好建模        |
| 持续交付      | 如何更有效及高效地发布软件产品                              |
| 按需虚拟化     | 能够按需创建机器并调整其大小                               |
| 基础设施自动化  | 很容易从一台机器扩展到多台                                |
| 小型自治团队   | 对某个服务的全生命周期负责                                |
| 大型集群系统   | Netflix分享了构建大型反脆弱系统的经验                      |

### 1.1 什么是微服务

微服务就是一些协同工作的**小**而**自治**的服务。

#### 1.1.1 很小，专注于做好一件事

微服务的理念：单块系统->抽象层或模块->内聚性->确定服务边界。

在考虑微服务的时候，内聚性这一概念很重要。[单一职责原则](http://programmer.97things.oreilly.com/wiki/index.php/The_Single_Responsibility_Principle)认为：把因相同原因而变化的东西聚合到一起，而把不同原因而变化的东西分离出来。该论述很好地强调了内聚性这一概念。

微服务将这个理念应用在独立的服务上。根据业务的边界来确定服务的边界，这样就很容易确定某个功能代码应该放在哪里。

代码库多小才算小？作者的答案是：

1. **足够小即可，不要过小**。用户通常能够意识到“过大”，那么当他们不觉得“过大”的时候，就说明足够小了。

2. **和团队结构匹配**。

服务越小越好吗？不是。服务越小，独立性带来的好处就越多，但是管理大量服务也会越复杂。

#### 1.1.2 自治性

1. **相互隔离**：服务的部署应该尽量隔离，尽量避免在一台机器上。服务之间均通过网络调用进行通信，从而加强了服务之间的隔离性，避免紧耦合。

2. **低耦合**：你是否能够修改一个服务并对其进行部署，而不影响其他任何服务？

### 1.2 主要好处

#### 1.2.1 技术异构性

最合适的技术，最大生产力：在不同的服务中使用最适合该服务的技术，也将从这些最适合的技术中受益。

#### 1.2.2 弹性

因为分散，所以安全：在单块系统中，如果服务不可用，则所有的功能都会不可用。在微服务架构中，服务边界形成了舱壁，本身就能够很好地处理服务不可用和功能降级的问题。

#### 1.2.3 扩展

独立，所以可以分别扩展：可以对单个微服务进行扩展，而不是对整个单块应用进行扩展，因此使系统扩展变得更容易。

#### 1.2.4 简化部署

独立，所以可以单独部署：两次发布之间的差异越大，出错的可能性就越大。单块系统任何变更都需要全部发版。但微服务可以单独发版，如果失败也可以较容易回滚。

#### 1.2.5 与组织机构相匹配

小型代码库+小团队更高效：大团队和大代码库经常容易引起问题。微服务架构可以很好地将架构与组织结构相匹配，避免出现过大的代码库。从而获得理想的团队大小及生产力。

#### 1.2.6 可组合性

支持不同应用种类：在微服务的架构中，系统会开放很多接缝供外部使用。现在的应用程序种类繁多，包括Web、原生应用、移动端Web、平板应用、可穿戴设备等，针对每一种都应该考虑如何对已有功能进行组合来实现这些应用。

#### 1.2.7 对可替代性的优化

因为小，所以可以删了重写：如果是单块系统庞大而无人敢碰，同时对业务至关重要，维护起来：工作量很大、风险很高。微服务架构，服务小，重写或移除一个或者多个服务的阻碍也很小。

### 1.3 面向服务的架构

实施SOA会遇到这些问题：

1. 通信协议（如SOAP)如何选择

2. 第三方中间件如何选择

3. 服务粒度如何确定

现有的SOA知识并不能帮助你把应用程序划小。它没有提到多大算大，也没有讨论如何在现实世界中有效地防止服务之间的过度耦合。由于这些点没有说清楚，所以你在实施SOA时会遇到很多问题。

在现实世界中，由于我们对项目的系统和架构有着更好的理解，所以能够更好地实施SOA，而这事实上就是微服务架构。可以认为微服务架构是SOA的一种特定方法。

### 1.4 其他分解技术

#### 1.4.1 共享库

缺点：

1. 无法选择异构技术

2. 会失去独立地对系统某一部分进行扩展的能力。

3. 每次更新都需要重新部署整个进程。

4. 缺乏一个明显的接缝来建立架构的安全性保护措施，从而无法确保系统的弹性。

#### 1.4.2 模块

缺点：

1. 有些语言不支持模块，则模块作者需要做更多工作来对模块进行适当的隔离，比如Java的OSGI。

2. 一个进程内，模块之间的耦合性难以控制。

3. 模块受限于语言，技术异构性受限。

### 1.5 没有银弹

使用微服务架构，必须要面对所有分布式系统需要面对的复杂性。

为了得到微服务的好处，需要：

1. 在部署、测试和监控等方面做很多的工作。

2. 考虑如何扩展系统。

3. 保证它们的弹性。

4. 处理类似分布式事务或者与CAP相关的问题。

### 1.6 小结

本章介绍了微服务、微服务与其它组合技术有何不同，以及它能够带来的主要好处是什么。

第2章 演化式架构师
---------------------

### 2.1 不准确的比较

架构师的一个重要职责是，确保团队游共同的技术愿景，以帮助我们向客户交付他们想要的系统。

架构师会经常被与建筑师进行对比。但事实上，架构师要创造的东西从设计上来说就是要足够灵活，有很好的适应性，并且能够根据用户的需求进行演化。

### 2.2 架构师的演化视角

| 特征                | 建筑师          | 城市规划师 | 软件架构师 |
|:-------------------:|:--------------:|:--------:|:---------:|
|需求变更              ｜少量            ｜ －       ｜   大量    |
|某个时间点后不再变化    ｜是              ｜ －       ｜   否     |
|把握大方向            ｜更多关注于细节    ｜ 是       ｜   是     |

结论：软件架构师应该像城市规划师一样，专注在大方向上，只在很有限的情况下参与到非常具体的细节实现中来。他们需要保证系统不但能够满足当前的需求，还能够应对将来的变化。而且他们还应该保证在这个系统上工作的开发人员要和使用这个系统的用户一样开心。

### 2.3 分区

架构师应该多关注区域（服务）之间的交互，而不需要过于关注各个分区（服务）内部发生的事情。

### 2.4 一个原则性的方法

#### 2.4.1 战略目标

软件架构师不用制定战略目标（那是公司高层的事儿），但是需要确保在技术层面的选择能够与之一致。

所以需要花费更多的时间和组织内非技术的部分（业务部门）进行交互。

#### 2.4.2 原则

根据战略目标制定一些具体的规则，称为原则，它不是一成不变的。

> Heroku的12 Factors（[https://12factor.net/zh_cn/](https://12factor.net/zh_cn/)）就是一组这样的设计原则。

#### 2.4.3 实践

通过相应的实践来保证原则能够得到实施，这些实践能够指导我们如何完成任务。

#### 2.4.4 将原则和实践相结合

要有一些重要的原则来指导系统的演化，同时也要有一些细节来指导如何实现这些原则。

在一些大型组织中，可能.NET团队有一套原则，Java团队有另一套原则，但背后的原则是相同的。

#### 2.4.5 真实世界的例子

真实世界中，实践改动可能很频繁，原则基本上不怎么变。

要确保这些实践和原则的贯彻落实，可以用：文档、示例、甚至可以创造一些工具来保证。

### 2.5 要求的标准

如何识别出各个服务需要遵守的通用规则：

#### 2.5.1 监控

确保所有的服务使用同样的方式报告健康状态及其与监控相关的数据。不要为了服务的具体实践而改变监控系统。

#### 2.5.2 接口

选用少数几种明确的接口技术有助于新消费者的集成。这不仅是指技术和协议（如：HTTP/REST），也包括了URL是动词还是名词，如何处理资源分页，如何处理不同版本的API？

#### 2.5.3 架构安全性

必须保证每个服务都可以应对下游服务的错误请求，才能保证系统的健壮性。

### 2.6 代码治理

用简单的方式把事情做对：

#### 2.6.1 范例

如果在系统中人们有比较好的代码范例可以模仿，那么他们也就不会错得很离谱。而且这些范例最好来自真实的代码，而不是专门实现的完美的例子。

#### 2.6.2 裁剪服务代码模板

当开发人员想要实现一个新服务时，所有实现核心属性的那些代码都应该是现成的。这些裁剪的服务代码模板不应该是某个中心化组织、团队或工作的职责，最好是通过合作的方式进行定义，使用内部开源的方式能够很好地完成这项工作。

### 2.7 技术债务

走捷径可能会引入技术债务。有时候系统的目标会发生改变，并且与现有的实现不符，这种情况下也会产生技术债务。

架构师的职责就是从更高的层次出发，理解如何做权衡。

### 2.8 例外管理

如果一个例外出现的次数多了，可能就需要修改原则来将这些理解固化下来。

微服务团队通常有更好的自治性，因此也有更好的自由度。

### 2.9 集中治理和领导

架构师的一个职责就是确保有一个技术愿景，那么治理就是要确保我们构建的系统符合这个愿景，而且在需要的时候还应对愿景进行演化。

一种有效的模式是，组建一个小组，由架构师来领导，每个交付团队都有人参加，并且保证有来自高层的支持。

### 2.10 建设团队

执行愿景不仅仅等同于做技术决定，更重要的事情，是帮助你的队友成长，帮助他们理解这个愿景，并保证他们可以积极地参与到愿景的实现和调整中来。

伟大的软件来自于伟大的人，如果你只担心技术问题，那么恐怕你看到的问题远远不及一半。

### 2.11 小结

演进式架构师应该承担的职责：愿景、同理心、合作、适应性、自治性、治理，应该理解，成功要靠不断地取舍来实现。

第3章 如何建模服务
---------------------

第4章 集成
---------------------

第5章 分解单块系统
---------------------

第6章 部署
---------------------

第7章 测试
---------------------

第8章 监控
---------------------

第9章 安全
---------------------

第10章 康威定律和系统设计
---------------------

第11章 规模化微服务
---------------------

第12章 总结
---------------------