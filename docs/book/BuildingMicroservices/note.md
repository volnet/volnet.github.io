微服务设计（Building Microservices）
========================================

[英]Sam Newman著

崔力强 张骏 译

第1章 微服务
---------------------

微服务的诞生离不开下面这些技术实践的发展，而这些技术在10年前几乎是很难想象的：

| 实践类型      |    作用/现象                                            |
|:------------:|:-----------------------------------------------------:|
| 领域驱动设计   | 帮助理解用代码呈现真实世界的重要性、告诉我们如何更好建模        |
| 持续交付      | 如何更有效及高效地发布软件产品                              |
| 按需虚拟化     | 能够按需创建机器并调整其大小                               |
| 基础设施自动化  | 很容易从一台机器扩展到多台                                |
| 小型自治团队   | 对某个服务的全生命周期负责                                |
| 大型集群系统   | Netflix分享了构建大型反脆弱系统的经验                      |

### 1.1 什么是微服务

微服务就是一些协同工作的**小**而**自治**的服务。

#### 1.1.1 很小，专注于做好一件事

微服务的理念：单块系统->抽象层或模块->内聚性->确定服务边界。

在考虑微服务的时候，内聚性这一概念很重要。[单一职责原则](http://programmer.97things.oreilly.com/wiki/index.php/The_Single_Responsibility_Principle)认为：把因相同原因而变化的东西聚合到一起，而把不同原因而变化的东西分离出来。该论述很好地强调了内聚性这一概念。

微服务将这个理念应用在独立的服务上。根据业务的边界来确定服务的边界，这样就很容易确定某个功能代码应该放在哪里。

代码库多小才算小？作者的答案是：

1. **足够小即可，不要过小**。用户通常能够意识到“过大”，那么当他们不觉得“过大”的时候，就说明足够小了。

2. **和团队结构匹配**。

服务越小越好吗？不是。服务越小，独立性带来的好处就越多，但是管理大量服务也会越复杂。

#### 1.1.2 自治性

1. **相互隔离**：服务的部署应该尽量隔离，尽量避免在一台机器上。服务之间均通过网络调用进行通信，从而加强了服务之间的隔离性，避免紧耦合。

2. **低耦合**：你是否能够修改一个服务并对其进行部署，而不影响其他任何服务？

### 1.2 主要好处

#### 1.2.1 技术异构性

最合适的技术，最大生产力：在不同的服务中使用最适合该服务的技术，也将从这些最适合的技术中受益。

#### 1.2.2 弹性

因为分散，所以安全：在单块系统中，如果服务不可用，则所有的功能都会不可用。在微服务架构中，服务边界形成了舱壁，本身就能够很好地处理服务不可用和功能降级的问题。

#### 1.2.3 扩展

独立，所以可以分别扩展：可以对单个微服务进行扩展，而不是对整个单块应用进行扩展，因此使系统扩展变得更容易。

#### 1.2.4 简化部署

独立，所以可以单独部署：两次发布之间的差异越大，出错的可能性就越大。单块系统任何变更都需要全部发版。但微服务可以单独发版，如果失败也可以较容易回滚。

#### 1.2.5 与组织机构相匹配

小型代码库+小团队更高效：大团队和大代码库经常容易引起问题。微服务架构可以很好地将架构与组织结构相匹配，避免出现过大的代码库。从而获得理想的团队大小及生产力。

#### 1.2.6 可组合性

支持不同应用种类：在微服务的架构中，系统会开放很多接缝供外部使用。现在的应用程序种类繁多，包括Web、原生应用、移动端Web、平板应用、可穿戴设备等，针对每一种都应该考虑如何对已有功能进行组合来实现这些应用。

#### 1.2.7 对可替代性的优化

因为小，所以可以删了重写：如果是单块系统庞大而无人敢碰，同时对业务至关重要，维护起来：工作量很大、风险很高。微服务架构，服务小，重写或移除一个或者多个服务的阻碍也很小。

### 1.3 面向服务的架构

实施SOA会遇到这些问题：

1. 通信协议（如SOAP)如何选择

2. 第三方中间件如何选择

3. 服务粒度如何确定

现有的SOA知识并不能帮助你把应用程序划小。它没有提到多大算大，也没有讨论如何在现实世界中有效地防止服务之间的过度耦合。由于这些点没有说清楚，所以你在实施SOA时会遇到很多问题。

在现实世界中，由于我们对项目的系统和架构有着更好的理解，所以能够更好地实施SOA，而这事实上就是微服务架构。可以认为微服务架构是SOA的一种特定方法。

### 1.4 其他分解技术

#### 1.4.1 共享库

缺点：

1. 无法选择异构技术

2. 会失去独立地对系统某一部分进行扩展的能力。

3. 每次更新都需要重新部署整个进程。

4. 缺乏一个明显的接缝来建立架构的安全性保护措施，从而无法确保系统的弹性。

#### 1.4.2 模块

缺点：

1. 有些语言不支持模块，则模块作者需要做更多工作来对模块进行适当的隔离，比如Java的OSGI。

2. 一个进程内，模块之间的耦合性难以控制。

3. 模块受限于语言，技术异构性受限。

### 1.5 没有银弹

使用微服务架构，必须要面对所有分布式系统需要面对的复杂性。

为了得到微服务的好处，需要：

1. 在部署、测试和监控等方面做很多的工作。

2. 考虑如何扩展系统。

3. 保证它们的弹性。

4. 处理类似分布式事务或者与CAP相关的问题。

### 1.6 小结

本章介绍了微服务、微服务与其它组合技术有何不同，以及它能够带来的主要好处是什么。

第2章 演化式架构师
---------------------

### 2.1 不准确的比较

架构师的一个重要职责是，确保团队游共同的技术愿景，以帮助我们向客户交付他们想要的系统。

架构师会经常被与建筑师进行对比。但事实上，架构师要创造的东西从设计上来说就是要足够灵活，有很好的适应性，并且能够根据用户的需求进行演化。

### 2.2 架构师的演化视角

| 特征                | 建筑师          | 城市规划师 | 软件架构师 |
|:-------------------:|:--------------:|:--------:|:---------:|
|需求变更              ｜少量            ｜ －       ｜   大量    |
|某个时间点后不再变化    ｜是              ｜ －       ｜   否     |
|把握大方向            ｜更多关注于细节    ｜ 是       ｜   是     |

结论：软件架构师应该像城市规划师一样，专注在大方向上，只在很有限的情况下参与到非常具体的细节实现中来。他们需要保证系统不但能够满足当前的需求，还能够应对将来的变化。而且他们还应该保证在这个系统上工作的开发人员要和使用这个系统的用户一样开心。

### 2.3 分区

架构师应该多关注区域（服务）之间的交互，而不需要过于关注各个分区（服务）内部发生的事情。

### 2.4 一个原则性的方法

#### 2.4.1 战略目标

软件架构师不用制定战略目标（那是公司高层的事儿），但是需要确保在技术层面的选择能够与之一致。

所以需要花费更多的时间和组织内非技术的部分（业务部门）进行交互。

#### 2.4.2 原则

根据战略目标制定一些具体的规则，称为原则，它不是一成不变的。

> Heroku的12 Factors（[https://12factor.net/zh_cn/](https://12factor.net/zh_cn/)）就是一组这样的设计原则。

#### 2.4.3 实践

通过相应的实践来保证原则能够得到实施，这些实践能够指导我们如何完成任务。

#### 2.4.4 将原则和实践相结合

要有一些重要的原则来指导系统的演化，同时也要有一些细节来指导如何实现这些原则。

在一些大型组织中，可能.NET团队有一套原则，Java团队有另一套原则，但背后的原则是相同的。

#### 2.4.5 真实世界的例子

真实世界中，实践改动可能很频繁，原则基本上不怎么变。

要确保这些实践和原则的贯彻落实，可以用：文档、示例、甚至可以创造一些工具来保证。

### 2.5 要求的标准

如何识别出各个服务需要遵守的通用规则：

#### 2.5.1 监控

确保所有的服务使用同样的方式报告健康状态及其与监控相关的数据。不要为了服务的具体实践而改变监控系统。

#### 2.5.2 接口

选用少数几种明确的接口技术有助于新消费者的集成。这不仅是指技术和协议（如：HTTP/REST），也包括了URL是动词还是名词，如何处理资源分页，如何处理不同版本的API？

#### 2.5.3 架构安全性

必须保证每个服务都可以应对下游服务的错误请求，才能保证系统的健壮性。

### 2.6 代码治理

用简单的方式把事情做对：

#### 2.6.1 范例

如果在系统中人们有比较好的代码范例可以模仿，那么他们也就不会错得很离谱。而且这些范例最好来自真实的代码，而不是专门实现的完美的例子。

#### 2.6.2 裁剪服务代码模板

当开发人员想要实现一个新服务时，所有实现核心属性的那些代码都应该是现成的。这些裁剪的服务代码模板不应该是某个中心化组织、团队或工作的职责，最好是通过合作的方式进行定义，使用内部开源的方式能够很好地完成这项工作。

### 2.7 技术债务

走捷径可能会引入技术债务。有时候系统的目标会发生改变，并且与现有的实现不符，这种情况下也会产生技术债务。

架构师的职责就是从更高的层次出发，理解如何做权衡。

### 2.8 例外管理

如果一个例外出现的次数多了，可能就需要修改原则来将这些理解固化下来。

微服务团队通常有更好的自治性，因此也有更好的自由度。

### 2.9 集中治理和领导

架构师的一个职责就是确保有一个技术愿景，那么治理就是要确保我们构建的系统符合这个愿景，而且在需要的时候还应对愿景进行演化。

一种有效的模式是，组建一个小组，由架构师来领导，每个交付团队都有人参加，并且保证有来自高层的支持。

### 2.10 建设团队

执行愿景不仅仅等同于做技术决定，更重要的事情，是帮助你的队友成长，帮助他们理解这个愿景，并保证他们可以积极地参与到愿景的实现和调整中来。

伟大的软件来自于伟大的人，如果你只担心技术问题，那么恐怕你看到的问题远远不及一半。

### 2.11 小结

演进式架构师应该承担的职责：愿景、同理心、合作、适应性、自治性、治理，应该理解，成功要靠不断地取舍来实现。

第3章 如何建模服务
---------------------

### 3.1 MusicCorp简介

作者打算用一个虚构的例子来解释微服务。

### 3.2 什么样的服务是好服务

#### 3.2.1 松耦合

修改一个服务，就不需要修改另一个服务。

#### 3.2.2 高内聚

如果要改变某个行为，最好只能在一个地方修改，然后可以尽快发布。

### 3.3 限界上下文

《领域驱动设计》的作者Eric说：“细胞之所以会存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜”。

#### 3.3.1 共享的隐藏模型

不同的限界上下文中，使用相同的模型进行通信。应该共享特定的模型，而不应该共享内部表示，可以避免潜在的紧耦合风险。

#### 3.3.2 模块和服务

单块系统中也要使用模块的概念进行划分，这些模块的边界就可以成为绝佳的微服务候选。

#### 3.3.3 过早划分

过早将一个系统划分成为微服务的代价非常高，尤其是在面对新领域时。很多时候，将一个已有的代码库划分成微服务，要比从头开始构建微服务简单得多。

### 3.4 业务功能

考虑组织内的限界上下文时，不应该从共享数据的角度来考虑，而应该从这些上下文能够提供的功能来考虑。避免出现贫血模型（仅包含CRUD的服务）。

首先要问自己“这个上下文时做什么用的”，然后再考虑“它需要什么样的数据”。

### 3.5 逐步划分上下文

从一开始识别出粗粒度的限界上下文，到这些限界上下文内部又出现了嵌套限界上下文。

有两种规则用来与外部协作：

1. 使用高层次的限界上下文，并将请求在内部映射给内部的嵌套上下文。

2. 高层次的限界上下文不应该被显式地建模成一个服务，而是直接将内部的嵌套上下文直接暴露出来。

使用哪种规则应该根据：

1. 组织结构

2. 代码的维护团队（如果是一个团队管理，则倾向于用第一种）

3. 如何更好地测试

等多个方面综合考虑。

### 3.6 关于业务概念的沟通

微服务之间如何就同一个业务概念进行通信，也是一件很重要的事情。基于业务领域的软件建模不应该止于限界上下文的概念。在组织内部共享的那些相同的术语和想法，也应该被反映到服务的接口上。以跟组织内通信相同的方式，来思考微服务之间的通信形式是非常有用的。

### 3.7 技术边界

服务边界通常不应该是技术接缝（按不同的技术，划分不同的服务），虽然这并不总是错的。

作者举例，某公司将前端和后端分拆成两个部分，形成两个服务，最后导致前后端每次都需要同时修改。

### 3.8 小结

什么是好服务，使用限界上下文寻找高内聚低耦合的接缝，通过将微服务与这些边界相匹配，保证最终的系统能够得到微服务提供的所有好处。

第4章 集成
---------------------

### 4.1 寻找理想的集成技术

#### 4.1.1 避免破坏性

尽量避免一个服务的修改会导致另一个服务的修改。

#### 4.1.2 保证API的技术无关性

技术日新月异，只有保持技术无关性才能更灵活。

#### 4.1.3 使你的服务易于消费方使用

好用的服务，才有意义。

增加一个客户端库可以简化消费方的使用，但是会造成耦合度增加。

#### 4.1.4 隐藏内部实现细节

避免使用倾向于暴露内部细节的技术。

### 4.2 为用户创建接口

此处“为用户创建接口”的标题是指为示例MusicCrop创建一个用户的例子。

接口通常不是一个简单的CRUD操作，而是一组相关性很强的业务集合，比如创建用户的例子：添加新客户可能会触发一个新流程，比如进行付账设置、发送欢迎邮件等。

### 4.3 共享数据库

**优点：**

- 简单、集成快

**缺点：**

使得高内聚和低耦合两者都难以实现

- 暴露内部细节，增加耦合性，使得变更表结构等变得困难重重；

- 数据库技术导致了对共享者的技术绑定，使得更换数据库变得困难重重；

- 使得程序逻辑也需要被共享者知道。

### 4.4 同步与异步

**同步：**

- 请求/响应：客户端发起一个请求，然后等待响应

**异步：**

特点：对运行时间较长的任务比较有用

- 请求/响应：客户端发起一个请求，然后注册一个回调，当服务操作结束之后，会调用该回调。

- 事件：客户端发布一个事件，然后期待协作者接收到该消息，并且知道该怎么做。因此可以在不影响客户端的情况下添加订阅者。

如何选择同步还是异步：

一个重要的因素是这种风格能否很好地解决复杂问题，比如如何处理跨服务边界的流程，而且这种流程有可能会运行很长时间。

### 4.5 编排与协同

**编排：**

就像管弦乐队的指挥，按照流程图的设计，执行每一步任务，如果是同步的请求/响应模式，甚至可以知道每一步是否成功。

缺点：

- 作为中心控制点承担了太多的职责。

- 大多数重量级编排方案都非常不稳定而且代价很大。

**协同：**

通过发布事件和订阅事件来消除耦合。

缺点：

- 看不到明显的业务流程图。

- 需要做一些额外的监控以确保正确性。

### 4.6 远程过程调用

#### 4.6.1 技术的耦合

类似Java RMI与特定的平台紧密绑定，对于服务端和客户端的技术选型造成了一定限制。而Thrift和protocol buffers对于不同的语言的支持很好。

#### 4.6.2 本地调用和远程调用并不相同

即便很多RPC的实现隐藏了远程调用的复杂性，但它们仍然不一样。

网络并不可靠，它随时有可能出错。

#### 4.6.3 脆弱性

那些能自动生成代码桩的技术，如Java RMI，任何修改都需要重新生成桩。导致了客户端和服务端的部署无法分离。

#### 4.6.4 RPC很糟糕吗

其实也不是。

不要对远程调用过度抽象，以至于网络因素完全被隐藏起来；

确保你可以独立地升级服务端的接口而不用强迫客户端升级；

在客户端中一定不要隐藏我们是在做网络调用这个事实；

在RPC的方式中经常会在客户端使用库，但是这些库如果在结构上组织得不够好，也可能会带来一些问题。

### 4.7 REST

REST是RPC的一种替代方案。

最重要的一点概念是：资源。

REST的风格可以参考：[Richardson的成熟度模型](http://martinfowler.com/articles/richardsonMaturityModel.html)

#### 4.7.1 REST和HTTP

REST并不限定是HTTP，但通常是HTTP。它们的定义都是针对资源的操作。

基于HTTP就可以利用到很多HTTP生态系统里的支撑工具和技术，比如缓存、代理、负载均衡、监控工具。

同样是基于HTTP，SOAP就用到了HTTP较少的特性，从而仅被当作传输协议来做RPC。

#### 4.7.2 超媒体作为程序状态的引擎

REST引入的用来避免客户端和服务端之间产生耦合的另一个原则是：HATEOAS（[Hypermedia As The Engine Of Application State](https://en.wikipedia.org/wiki/HATEOAS)）。

作者举了一个形象的例子：人类和网页这个超媒体之间是如何交互的。考虑Amazon.com这个站点。随着时间的推移，购物车的位置、图像、链接都有可能发生变化，但是人类足够聪明，你还是能够找到它。无论确切的形式和底层使用的控件发生怎样的改变，我们仍然很清楚如果你想要浏览购物车的话，应该去点哪个按钮。这就是为什么在网页上可以做出一些增量的修改，只要这些客户和站点之间的隐式约定仍然满足，这些修改就不会破坏站点的功能。

使用超媒体控制时，我们希望电子用户（服务）也能达到同样的聪明程度。可以用类似下面的表示：

```
<album>
  <name>Give Blood</name>
  <link rel="/artist" href="/artist/theBrakes" />
  <description>Aweson, short, brutish, funny and loud. Must buy!</description>
  <link rel="/instantpurchase" href="/instantpurchase/1234" />
</album>
```

其中`rel`很好地屏蔽了`href`。这样我们就可以随意改变链接的展现形式。

缺点：

客户端和服务端之间的通信次数会比较多，因为客户端需要不断地发现链接、请求、再发现链接，直到找到自己想要进行的那个操作，所以终究还是需要做一些取舍。

#### 4.7.3 JSON、XML还是其他

JSON轻量，XML全面。

JSON的缺点：XML使用链接来进行超媒体控制，而JSON标准中并没有类似的东西，所以出现了很多不同的自定义的方式在JSON中进行超媒体控制。[HAL](http://stateless.co/hal_specification.html)就是其中一种，

#### 4.7.4 留心过多的约定

有一些工具会为了短期利益而牺牲长期利益，为了让你一开始启动地足够快，它们会使用一些不好的实践。比如有些框架很容易表示数据库对象，并把它们反序列化成进程内的对象，然后直接暴露给外部。这种方式内在的耦合性所带来的痛苦会远远大于从一开始就消除概念之间的耦合所需要的代价。

避免它：先设计外部接口，再实现内部持久化。

#### 4.7.5 基于HTTP的REST的缺点

易用性角度看：

基于HTTP的REST无法自动生成客户端桩代码，而RPC可以。

在客户端和服务端共享代码是非常危险的。

有些WEB框架无法很好地支持所有的HTTP动词，也就可能无法完整地使用REST风格了。

性能：

每个HTTP请求的封装开销可能是个问题。JSON和Thrift等这样的二进制协议也是无法比的。和WebSocket等TCP传输协议也比不了。因此它对低延迟的场景并不是最优选项。

即便这些缺点，在选择服务之间的交互方式时，基于HTTP的REST仍然是一个比较合理的默认选择。

### 4.8 实现基于事件的异步协作方式

#### 4.8.1 技术选择

主要有两个部分需要考虑：微服务发布事件机制和消费者接收事件机制。

1. 使用消息队列：

  类似RabbitMQ这样的消息代理能够处理上述两个方面的问题。

  但是中间件服务厂商倾向于把很多软件打包进去，比如ESB。原则：尽量让中间件保持简单，而把业务逻辑放在自己的服务中。

2. 另一种方法是使用HTTP来传播事件。

  ATOM是一个符合REST规范的协议，可以通过它提供资源聚合（feed）的发布服务，而且有很多现成的客户端库可以用来消费该聚合。这样当客户服务发生改变时，只需简单地向该聚合发布一个事件即可。消费者会轮询该聚合以查看变化。另一方面，现成的ATOM规范和与之相关的库用起来非常方便，而且HTTP能够很好地处理伸缩性。

  但是有一种场景需要避免，即多个工作者处理了同一条消息，从而造成浪费。如果使用消息代理，一个标准的队列就可以很好地处理这种场景。而使用ATOM的话，就需要自己在所有的工作者之间维护一个共享的状态来减少上述情况发生。

#### 4.8.2 异构架构的复杂性

1. [灾难性故障转移（Catastrophic failover）](http://martinfowler.com/bliki/CatastrophicFailover.html)

  例如：代码存在bug会导致工作者崩溃。当工作者崩溃之后，这个请求上的锁会超时，然后该请求就会被放回到队列中。另一个工作者会重新尝试处理该请求，然后它也会崩溃。

  可以通过设置最大作业重试次数，以及消息医院（死信队列）来存放失败的消息。

2. 需要确保流程有很好的监控机制，并考虑使用关联ID，这种机制可以帮助你对跨进程的请求进行追踪。

### 4.9 服务即状态机

当消费者想要对客户做修改时，它会向客户服务发送一个合适的请求。客户服务根据自己的逻辑决定是否接受该请求。客户服务控制了所有与客户生命周期相关的事件。我们想要避免简单地对CRUD进行封装的贫血服务。如果出现了在客户服务之外与其进行相关的修改的情况，那么你就失去了内聚性。

### 4.10 响应式扩展

当你需要做一些基于多个服务调用的操作时，尝试一下适合你所选用技术栈的响应式扩展（[Reactive extensions，RX](https://msdn.microsoft.com/library/hh242985.aspx)）。

响应式扩展提供了一种机制，在此之上，你可以把多个调用的结果组装起来并在此基础上执行操作。

第5章 分解单块系统
---------------------

第6章 部署
---------------------

第7章 测试
---------------------

第8章 监控
---------------------

第9章 安全
---------------------

第10章 康威定律和系统设计
---------------------

第11章 规模化微服务
---------------------

第12章 总结
---------------------
